Korzystanie z usług sieciowych
==============================

Kiedy już pozyskiwanie dokumentów przez HTTP i ich przetwarzenie stało się łatwe, ludziom nie zajęło dużo czasu opracowanie podejścia, w którym zaczęli tworzyć dokumenty specjalnie zaprojektowane do użytku przez inne programy (tj. coś innego niż HTML, który ma być wyświetlany w przeglądarce).

Istnieją dwa popularne formaty, których używamy przy wymianie danych w sieci. eXtensible Markup Language (XML, z ang. rozszerzalny język znaczników) jest używany od bardzo dawna i najlepiej nadaje się do wymiany danych w formie dokumentów. Gdy programy chcą tylko wymieniać ze sobą słowniki, listy lub inne wewnętrzne informacje, używają JavaScript Object Notation (JSON, z ang. notacja obiektowa JavaScript, patrz [www.json.org](https://www.json.org)). Przyjrzymy się obu formatom.

XML
---

XML wygląda bardzo podobnie do HTMLa, ale XML jest bardziej uporządkowany. Oto fragment dokumentu XML:

~~~~ {.xml}
<osoba>
  <imie>Chuck</imie>
  <telefon typ="miedzynar">
    +1 734 303 4456
  </telefon>
  <email ukryty="tak" />
</osoba>
~~~~

Każda para otwierająca (np. `<osoba>`) i zamykająca tagi (np. `</osoba>`) reprezentuje *element* lub *węzeł* (ang. node) o tej samej nazwie co znacznik (np. `osoba`). Każdy element może mieć jakiś tekst, pewne atrybuty (np. `ukryty`) i inne zagnieżdżone elementy. Jeśli element XML jest pusty (tzn. nie ma treści), to może być przedstawiony za pomocą samozamykającego się tagu (np. `<email />`).

Często pomocne jest myślenie o dokumencie XML jako o strukturze drzewa, w którym znajduje się najwyższy element (tutaj: `osoba`), a inne znaczniki (np. `telefon`) są oznaczane jako *dzieci* elmenetów będących ich *rodzicami*.

![Drzewiasta reprezentacja XMLa](height=2.0in@../images/xml-tree)

Parsowanie XML
--------------

\index{ElementTree}
\index{ElementTree!fromstring}
\index{ElementTree!find}

Oto prosta aplikacja, która przetwarza część XMLa i wyodrębnia z niego niektóre elementy danych:

\VerbatimInput{../code3/xml1.py}

Potrójny apostrof (`'''`), jak również potrójny cudzysłów (`"""`), pozwalają na tworzenie napisów, które obejmują wiele linii.

Wywołanie `fromstring` zamienia reprezentację XMLa z ciągu znaków na "drzewo" elementów XML. Gdy element XML znajduje się w drzewie, posiadamy szereg metod, które możemy wywołać by wyodrębnić interesujące nas dane z ciągu znaków będącego XMLem. Funkcja `find` przeszukuje drzewo XML i wyciąga element, który pasuje do określonego znacznika.

~~~~
Imię: Chuck
Attr: tak
~~~~

Użycie parsera XML takiego jak `ElementTree` ma tę zaletę, że choć XML w tym przykładzie jest dość prosty, to okazuje się, że istnieje wiele reguł dotyczących poprawności składni XML, a użycie `ElementTree` pozwala nam na wydobycie danych z XML bez martwienia się o te reguły.

Przechodzenie w pętli po węzłach
--------------------------------

\index{ElementTree!findall}
\index{ElementTree!get}

Często XML ma wiele węzłów i musimy napisać pętlę, tak by je wszystkie przetworzyć. Przyjmijmy, że mamy do przeanalizowania prostą bazę użytkowników, która jest zapisana w postaci XMLa. W poniższym programie przechodzimy w pętli przez wszystkie elementy o nazwie `user`:

\VerbatimInput{../code3/xml2.py}

Metoda `findall` zwraca Pythonową listę poddrzew, które reprezentują struktury `user` w drzewie XML. Następnie możemy napisać pętlę `for`, która analizuje każdy węzeł o nazwie `user` i wypisuje jego elementy tekstowe `name` i `id` oraz atrybut `x`.

~~~~
Liczba użytkowników: 2
Name Chuck
Id 001
Attribute 2
Name Brent
Id 009
Attribute 7
~~~~

Ważne jest, by uwzględnić wszystkie elementy poziomu nadrzędnego w instrukcji `findall` z wyjątkiem elementu najwyższego poziomu (np. `users/user`). W przeciwnym razie, Python nie znajdzie żadnych szukanych przez nas węzłów.

~~~~ {.python}
import xml.etree.ElementTree as ET

input = '''
<stuff>
  <users>
    <user x="2">
      <id>001</id>
      <name>Chuck</name>
    </user>
    <user x="7">
      <id>009</id>
      <name>Brent</name>
    </user>
  </users>
</stuff>'''

stuff = ET.fromstring(input)

lst = stuff.findall('users/user')
print('Liczba użytkowników:', len(lst))

lst2 = stuff.findall('user')
print('Liczba użytkowników:', len(lst2))
~~~~

Zmienna `lst` przechowuje wszystkie elementy `user`, które są zagnieżdżone w ich rodzicu, tj. w `users`. Zmienna `lst2` szuka elementów `user`, które miałyby być zagnieżdżone w obrębie najwyższego poziomu, czyli `staff`, ale tam nie ma żadnego takiego węzła.

~~~~
Liczba użytkowników: 2
Liczba użytkowników: 0
~~~~

JSON
----

\index{JSON}
\index{JavaScript Object Notation}

Format JSON został zainspirowany obiektowym i tablicowym formatem używanym w języku JavaScript. Ponieważ Python został wymyślony przed JavaScriptem, składnia Pythona dla słowników i list wpłynęła na składnię JSON. Format JSON jest więc prawie identyczny z połączeniem list i słowników Pythona.

Oto kodowanie JSON, które w przybliżeniu odpowiada prostemu XMLowi, który widzieliśmy wcześniej:

~~~~ {.json}
{
  "imie" : "Chuck",
  "telefon" : {
    "typ" : "miedzynar",
    "numer" : "+1 734 303 4456"
   },
   "email" : {
     "ukryty" : "tak"
   }
}
~~~~

Zapewne zauważysz pewne różnice. Po pierwsze, w XMLu możemy dodać do znacznika "telefon" atrybuty takie jak "miedzynar". W JSON mamy po prostu pary klucz-wartość. Również znacznik XML "osoba" zniknął i został zastąpiony zestawem zewnętrznych nawiasów klamrowych.

Ogólnie rzecz biorąc, struktury JSON są prostsze niż XML, ponieważ JSON ma mniej możliwości niż XML. Ale JSON ma tę zaletę, że mapuje *bezpośrednio* do jakiegoś połączenia słowników i list. A ponieważ prawie wszystkie języki programowania mają coś w rodzaju słowników i list Pythona, JSON jest bardzo naturalnym formatem wymiany danych pomiędzy dwoma współpracującymi ze sobą programami.

JSON szybko staje się najczęściej wybieranym formatem dla prawie całej wymiany danych pomiędzy aplikacjami, właśnie ze względu na swoją relatywną prostotę w porównaniu do XMLa.

Parsowanie JSONa
----------------

Budujemy nasz JSON poprzez zagnieżdżanie słowników i list w zależności od naszych potrzeb. W poniższym przykładzie przedstawiamy listę użytkowników, gdzie każdy użytkownik jest zestawem par klucz-wartość (czyli słownikiem). Mamy więc listę słowników.

W poniższym programie wykorzystujemy wbudowaną bibliotekę `json` do parsowania JSONa i odczytywania z niego danych. Porównaj kod z wcześniejszym przykładem pracującym na XMLu. JSON ma mniej detali, więc musimy z góry wiedzieć, że otrzymujemy listę i że lista ta składa się z użytkowników, a każdy użytkownik jest zestawem par klucz-wartość. JSON jest bardziej zwięzły (zaleta), ale również mniej samoopisujący się (wada).

\VerbatimInput{../code3/json2.py}

Jeśli porównasz kod wyodrębniający dane z JSONa i XMLa, to zauważysz w tym przykładzie, że to, co otrzymujemy z `json.loads()`, jest listą Pythona, po której przechodzimy pętlą `for`, a każda pozycja na tej liście jest słownikiem Pythona. Kiedy już JSON zostanie przeparsowany, możemy użyć operatora indeksu, tak by wyodrębnić różne fragmenty danych związane z użytkownikiem. Nie musimy korzystać z biblioteki JSON by przekopać się przez parsowanego JSONa, ponieważ zwracane dane są po prostu natywnymi strukturami Pythona.

Wynik powyższego programu jest dokładnie taki sam jak wersji z XMLem.

~~~~
Liczba użytkowników: 2
Name Chuck
Id 001
Attribute 2
Name Brent
Id 009
Attribute 7
~~~~

Ogólnie rzecz biorąc, w obrębie usług sieciowych istnieje branżowy trend polegający na odchodzeniu od XMLa i zmierzaniu w kierunku JSONa. JSON jest prostszy i bardziej bezpośrednio mapuje do natywnych struktur danych, które mamy już w językach programowania, więc kod parsujący JSON i wyodrębniający dane jest w takim przypadku zazwyczaj prostszy i bardziej czytelny. Z drugiej strony, XML jest bardziej samoopisujący się niż JSON, a więc są pewne zastosowania, w których XML zachowuje przewagę. Na przykład większość edytorów tekstu przechowuje dokumenty wewnętrznie przy użyciu XMLa, a nie JSONa.

API – Interfejsy programowania aplikacji
----------------------------------------

Posiadamy teraz możliwość wymiany danych pomiędzy aplikacjami przy użyciu protokołu HTTP oraz sposób na reprezentowanie skomplikowanych danych, które wysyłamy tam i z powrotem pomiędzy aplikacjami, przy użyciu XMLa lub JSONa.

Następnym krokiem jest rozpoczęcie definiowania i dokumentowania "umów" pomiędzy aplikacjami wykorzystującymi powyższe techniki. Ogólna nazwa takiej umowy pomiędzy aplikacjami to *interfejsy programowania aplikacji* (ang. Application Program Interfaces, API). Kiedy używamy API, zazwyczaj jeden z programów udostępnia zestaw *usług* do wykorzystania przez inne aplikacje i publikuje API (tzn. "zasady"), których należy przestrzegać, by uzyskać dostęp do usług świadczonych przez ten program.

Gdy zaczynamy budować nasze programy, w których działanie obejmuje dostęp do usług świadczonych przez inne programy, nazywamy to podejście *architekturą zorientowaną na usługi* (ang, Service-Oriented Architecture, SOA). Podejście SOA to takie, w którym cała nasza aplikacja korzysta z usług innych aplikacji. Podejście inne niż SOA to takie, w którym aplikacja jest pojedynczą, samodzielną aplikacją, która zawiera cały kod niezbędny do jej implementacji i wdrożenia.

Podczas korzystania z sieci widzimy wiele przykładów SOA. Możemy wejść na stronę internetową i zarezerwować podróże lotnicze, hotele i wypożyczyć samochody, a wszystko to z poziomu jednej strony. Dane dotyczące hoteli nie są przechowywane na serwerach linii lotniczych. Zamiast tego, serwery linii lotniczych kontaktują się z usługami znajdującymi się na serwerach rezerwacji hotelowychm pobierają dane dotyczące hoteli i przedstawiają je użytkownikowi. Kiedy użytkownik wyraża zgodę na dokonanie rezerwacji hotelowej za pomocą strony internetowej linii lotniczych, strona ta korzysta z innej usługi internetowej w systemach rezerwacji hotelowych, tak aby faktycznie dokonać tej rezerwacji. A gdy przychodzi czas, by obciążyć Twoją kartę płatniczą za całą transakcję, w proces ten włączają się jeszcze inne serwery.

![SOA – architektura zorientowana na usługi](height=3.0in@../images/soa)

Architektura zorientowana na usługi ma wiele zalet, w tym: (1) zawsze przechowujemy tylko jedną kopię danych (jest to szczególnie ważne w przypadku rezerwacji hotelowych, w których nie chcemy wykonywać nadmiernych i niewykonalnych zobowiązań) oraz (2) właściciele danych mogą ustalić zasady korzystania z ich danych. Dzięki tym zaletom, system SOA musi być starannie zaprojektowany, tak aby działał wydajnie i spełniał potrzeby użytkownika.

Kiedy aplikacja udostępnia przez internet zestaw usług w swoim API, nazywamy to *usługą sieciową* (ang. web service).

Bezpieczeństwo i korzystanie z API
----------------------------------

\index{OAuth}
\index{API!key}

Dość często zdarza się, że chcąc skorzystać z API jakiegoś dostawcy, musisz posiadać tzw. klucz API. Ogólna idea jest taka, że dostawcy usług chcą wiedzieć, kto korzysta z ich usług i w jakim stopniu ich używa. Być może mają oni darmowe i płatne wersje swoich usług lub mają politykę ograniczającą liczbę zapytań, które pojedyncza osoba może wysłać w danym odcinku czasu.

Czasami jest tak, że po otrzymaniu klucza API po prostu dołączasz go jako część danych w zapytaniu POST lub jako parametr w adresie URL podczas wywoływania API.

Innym razem dostawca usług chce mieć większą pewność co do źródła zapytań i z tego powodu oczekuje, że będziesz wysyłał kryptograficznie podpisane wiadomości z wykorzystaniem tzw. współdzielonego klucza i sekretu. Bardzo popularną technologią, która jest używana do podpisywania tego rodzaju zapytań, jest *OAuth*. Więcej o tym protokole możesz przeczytać na stronie [www.oauth.net](https://www.oauth.net).

Na szczęście istnieje wiele wygodnych i darmowych bibliotek OAuth, dzięki czemu możesz uniknąć implementowania OAuth od zera. Biblioteki mają różny stopień skomplikowania i możliwości, a informacje o nich znajdują się na stronie internetowej OAuth.

Słowniczek
----------

API
:   Interfejs programowania aplikacji. Umowa pomiędzy aplikacjami, która określa schematy interakcji pomiędzy dwoma komponentami tych aplikacji.
\index{API}

ElementTree
:   Wbudowana biblioteka Pythona służąca do parsowania danych XML.
\index{ElementTree}

JSON
:   Notacja obiektowa JavaScript. Format, który pozwala na oznakowanie ustrukturyzowanych danych w oparciu o składnię obiektów JavaScript.
\index{JSON}
\index{JavaScript Object Notation}

SOA
:   Architektura zorientowana na usługi. Sytuacja, w której aplikacja składa się z połączonych w sieci komponentów.
\index{SOA}
\index{Service Oriented Architecture}

XML
:   Rozszerzalny język znaczników. Format, który pozwala na oznakowanie danych strukturalnych.
\index{XML}
\index{eXtensible Markup Language}

Aplikacja nr 1: usługa sieciowa OpenStreetMap do geokodowania
-------------------------------------------------------------

\index{OpenStreetMap}
\index{geocoding}
\index{web service}

OpenStreetMap posiada usługę internetową Nominatim, który pozwala nam korzystać z ich dużej bazy danych geograficznych. Możemy przesłać do ich geokodującego API ciąg znaków geograficznych, takich jak "Ann Arbor, MI", i sprawić, że OpenStreetMap zwróci swoje najbardziej prawdopodobne przypuszczenie dotyczące tego, gdzie na mapie możemy odnaleźć nasz ciąg znaków.

Usługa geokodowania jest bezpłatna, ale ograniczona ilościowo, więc w aplikacji komercyjnej nie możesz korzystać z API w sposób nieograniczony. Ale jeśli np. masz jakieś dane z ankiety, w której użytkownicy wprowadzili w polu danych jakąś lokalizację w dowolnym formacie, to możesz użyć tego API, tak by całkiem dobrze oczyścić swoje dane.

*Używając bezpłatnego API, takiego jak API geokodowania OpenStreetMap, korzystanie z zasobów odbywa się z poszanowaniem pewnych zasad. Jeśli zbyt wiele osób będzie nadużywać danej usługi, to np. OpenStreetMap może zrezygnować z udostępniania bezpłatnej wersji lub znacznie ją ograniczyć.*

\index{rate limiting}

Możesz zapoznać się z dokumentacją online dotyczącą tej usługi^[<https://nominatim.org/release-docs/develop/api/Search/>], ale jest ona na tyle prosta, że możesz ją nawet przetestować za pomocą przeglądarki, wpisując w niej następujący adres URL:

[`https://nominatim.openstreetmap.org/search.php?q=Ann%20Arbor%2C%20MI&format=geojson&limit=1`](https://nominatim.openstreetmap.org/search.php?q=Ann%20Arbor%2C%20MI&format=geojson&limit=1)

Poniżej znajduje się prosta aplikacja zachęcająca użytkownika do wyszukania informacji geograficznych o wprowadzonej nazwie miejsca. Aplikacja wywołuje API geokodowania OpenStreetMap i pobiera informacje ze zwróconego JSONa.

\VerbatimInput{../code3/geojson.py} 

Program pobiera ciąg znaków i konstruuje adres URL zawierający wprowadzony ciąg wyszukiwania jako prawidłowo zakodowany parametr adresu URL, a następnie używa `urllib` do pobrania tekstu z API geokodowania OpenStreetMap. W przeciwieństwie do stałej/niezmiennej strony internetowej, otrzymywane dane zależą od parametrów, które wysyłamy, oraz od danych geograficznych przechowywanych na serwerach OpenStreetMap.

Kiedy pobierzemy dane JSON, parsujemy je za pomocą biblioteki `json` i sprawdzamy kilka rzeczy, tak aby upewnić się, że otrzymaliśmy dobre dane, a następnie pobieramy informacje, których szukamy.

Wynik działania programu jest następujący (część zwróconych danych JSON została usunięta):

~~~~
$ python3 geojson.py 
Podaj nazwę miejsca: Ann Arbor, MI
Pobieranie https://nominatim.openstreetmap.org/search.php?q=Ann+Arbor%2C+MI&format=geojson&limit=1
Pobrano 587 znaków
~~~~

~~~~ {.json}
{
    "type": "FeatureCollection",
    "licence": "Data \u00a9 OpenStreetMap contributors, ODbL 1.0. https://osm.org/copyright",
    "features": [
        {
            "type": "Feature",
            "properties": {
                "place_id": 146750,
                "osm_type": "node",
                "osm_id": 27023455,
                "display_name": "Ann Arbor, Washtenaw County, Michigan, 48104, United States of America",
                "place_rank": 16,
                "category": "place",
                "type": "city",
                "importance": 0.837069344370284,
                "icon": "https://nominatim.openstreetmap.org/images/mapicons/poi_place_city.p.20.png"
            },
            "bbox": [
                -83.8912291,
                42.1081569,
                -83.5712291,
                42.4281569
            ],
            "geometry": {
                "type": "Point",
                "coordinates": [
                    -83.7312291,
                    42.2681569
                ]
            }
        }
    ]
}
szer. geogr. 42.2681569 dł. geogr. -83.7312291
Ann Arbor, Washtenaw County, Michigan, 48104, United States of America
~~~~

~~~~
Podaj nazwę miejsca:
~~~~

Możesz pobrać [pl.py4e.com/code3/geoxml.py](https://pl.py4e.com/code3/geoxml.py), aby sprawdzić wariant XML w API geokodowania OpenStreetMap.

**Część 1: Zmień** [`geojson.py`**`](https://pl.py4e.com/code3/geojson.py) **lub** [`geoxml.py`](https://pl.py4e.com/code3/geoxml.py) **w celu wypisania nazwy stanu z pobranych danych (jeżeli podane miejsce jest w USA). Dodaj sprawdzanie błędów, tak aby Twój program nie wyświetlał danych z mechanizmu traceback w momencie gdy w danych nie ma nazwy stanu. Gdy kod już zacznie działać, wyszukaj "Atlantic Ocean" i upewnij się, że obsługuje on lokalizacje, które nie znajdują się w żadnym kraju.**


Application 2: Twitter
----------------------

As the Twitter API became increasingly valuable, Twitter went from an
open and public API to an API that required the use of OAuth signatures
on each API request. 

For this next sample program, download the files
*twurl.py*, *hidden.py*, *oauth.py*, and *twitter1.py* from
[www.py4e.com/code](http://www.py4e.com/code3)
and put them all in a folder on your computer.

To make use of these programs you will need to have a Twitter account,
and authorize your Python code as an application, set up a key, secret,
token and token secret. You will edit the file
*hidden.py* and put these four strings into the
appropriate variables in the file:

\VerbatimInput{../code3/hidden.py} 

The Twitter web service are accessed using a URL like this:

<https://api.twitter.com/1.1/statuses/user_timeline.json>

But once all of the security information has been added, the URL will
look more like:

~~~~
https://api.twitter.com/1.1/statuses/user_timeline.json?count=2
&oauth_version=1.0&oauth_token=101...SGI&screen_name=drchuck
&oauth_nonce=09239679&oauth_timestamp=1380395644
&oauth_signature=rLK...BoD&oauth_consumer_key=h7Lu...GNg
&oauth_signature_method=HMAC-SHA1
~~~~

You can read the OAuth specification if you want to know more about the
meaning of the various parameters that are added to meet the security
requirements of OAuth.

For the programs we run with Twitter, we hide all the complexity in the
files *oauth.py* and *twurl.py*. We simply
set the secrets in *hidden.py* and then send the desired
URL to the *twurl.augment()* function and the library
code adds all the necessary parameters to the URL for us.

This program retrieves the timeline for a
particular Twitter user and returns it to us in JSON format in a string.
We simply print the first 250 characters of the string:

\VerbatimInput{../code3/twitter1.py} 
\begin{trinketfiles}
../code3/twurl.py
\end{trinketfiles}

When the program runs it produces the following output:

~~~~
Enter Twitter Account:drchuck
Retrieving https://api.twitter.com/1.1/ ...
[{"created_at":"Sat Sep 28 17:30:25 +0000 2013","
id":384007200990982144,"id_str":"384007200990982144",
"text":"RT @fixpert: See how the Dutch handle traffic
intersections: http:\/\/t.co\/tIiVWtEhj4\n#brilliant",
"source":"web","truncated":false,"in_rep
Remaining 178

Enter Twitter Account:fixpert
Retrieving https://api.twitter.com/1.1/ ...
[{"created_at":"Sat Sep 28 18:03:56 +0000 2013",
"id":384015634108919808,"id_str":"384015634108919808",
"text":"3 months after my freak bocce ball accident,
my wedding ring fits again! :)\n\nhttps:\/\/t.co\/2XmHPx7kgX",
"source":"web","truncated":false,
Remaining 177

Enter Twitter Account:
~~~~

Along with the returned timeline data, Twitter also returns metadata
about the request in the HTTP response headers. One header in
particular, `x-rate-limit-remaining`, informs us how many
more requests we can make before we will be shut off for a short time
period. You can see that our remaining retrievals drop by one each time
we make a request to the API.

In the following example, we retrieve a user's Twitter friends, parse
the returned JSON, and extract some of the information about the
friends. We also dump the JSON after parsing and "pretty-print" it with
an indent of four characters to allow us to pore through the data when
we want to extract more fields.

\VerbatimInput{../code3/twitter2.py} 
\begin{trinketfiles}
../code3/twurl.py
\end{trinketfiles}

Since the JSON becomes a set of nested Python lists and dictionaries, we
can use a combination of the index operation and `for` loops
to wander through the returned data structures with very little Python
code.

The output of the program looks as follows (some of the data items are
shortened to fit on the page):

~~~~
Enter Twitter Account:drchuck
Retrieving https://api.twitter.com/1.1/friends ...
Remaining 14
~~~~

~~~~ {.json}
{
  "next_cursor": 1444171224491980205,
  "users": [
    {
      "id": 662433,
      "followers_count": 28725,
      "status": {
        "text": "@jazzychad I just bought one .__.",
        "created_at": "Fri Sep 20 08:36:34 +0000 2013",
        "retweeted": false,
      },
      "location": "San Francisco, California",
      "screen_name": "leahculver",
      "name": "Leah Culver",
    },
    {
      "id": 40426722,
      "followers_count": 2635,
      "status": {
        "text": "RT @WSJ: Big employers like Google ...",
        "created_at": "Sat Sep 28 19:36:37 +0000 2013",
      },
      "location": "Victoria Canada",
      "screen_name": "_valeriei",
      "name": "Valerie Irvine",
    }
  ],
 "next_cursor_str": "1444171224491980205"
}
~~~~

~~~~
leahculver
   @jazzychad I just bought one .__.
_valeriei
   RT @WSJ: Big employers like Google, AT&amp;T are h
ericbollens
   RT @lukew: sneak peek: my LONG take on the good &a
halherzog
   Learning Objects is 10. We had a cake with the LO,
scweeker
   @DeviceLabDC love it! Now where so I get that "etc

Enter Twitter Account:
~~~~

The last bit of the output is where we see the for loop reading the five
most recent "friends" of the *@drchuck* Twitter account
and printing the most recent status for each friend. There is a great
deal more data available in the returned JSON. If you look in the output
of the program, you can also see that the "find the friends" of a
particular account has a different rate limitation than the number of
timeline queries we are allowed to run per time period.

These secure API keys allow Twitter to have solid confidence that they
know who is using their API and data and at what level. The
rate-limiting approach allows us to do simple, personal data retrievals
but does not allow us to build a product that pulls data from their API
millions of times per day.


