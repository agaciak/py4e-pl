% Python dla wszystkich 
% Eksploracja danych z Python 3
% Dr Charles R. Severance

Dlaczego powinieneś nauczyć się pisać programy?
===============================================

Pisanie programów (lub programowanie) jest bardzo twórczą i satysfakcjonującą 
aktywnością. Możesz pisać programy z wielu powodów, od zarabiania na życie,
przez rozwiązywanie trudnych problemów analizy danych, po zabawę i pomaganie
komuś w rozwiązaniu problemu. Poniższa książka zakłada, że *każdy* powienien
wiedzieć jak programować oraz że gdy już dowiesz się jak programować, to 
zorientujesz się co chcesz zrobić ze swoimi nowo odkrytymi umiejętnościami.

W codziennym życiu jesteśmy otoczeniu przez komputery, począwszy od laptopów,
po smartfony. Możemy myśleć o tych komputerach jako o naszych
"osobistych asystentach", którzy w naszym imieniu mogą zająć się wieloma
rzeczami. Sprzęt we współczesnych komputerach jest zasadniczo
zbudowany tak, aby nieustannie zadawać nam pytanie "Co mam teraz zrobić?".

![Osobisty asystent cyfrowy](height=1.0in@../images/pda)

Programiści dodają do sprzętu system operacyjny oraz zbiór aplikacji,
dzięki czemu w ten sposób otrzymujemy osobistego asystenta cyfrowego, który
okazuje się całkiem pomocny i zdolny do wsparcia nas w wielu różnych sprawach.

Nasze komputery są szybkie i mają ogromne zasoby pamięci -- ten fakt mógłby
być dla nas bardzo pomocny gdybyśmy tylko znali język do porozumiewania się
i wyjaśniania komputerowi co chcemy aby dla nas "teraz zrobił". Gdybyśmy
znali taki język, to moglibyśmy powiedzieć komputerowi by wykonał za nas
pewne powtarzające się czynności. Co ciekawe, to, co komputery potrafią 
najlepiej, to często rzeczy, które my, ludzie, uważamy za nudne i otępiające.

Na przykład, spójrz na pierwsze trzy akapity tego rozdziału i powiedz mi
które słowo było najczęście użyte oraz ile razy to słowo zostało użyte.
Podczas gdy byłeś w stanie przeczytać i zrozumieć słowa w ciągu kilku sekund,
zliczanie ich jest niemalże bolesne, ponieważ nie jest to tego rodzaju problem,
dla którego zostały zaprojektowane ludzkie umysły. W przypadku komputera jest
na odwrót -- czytanie i rozumienie tekstu z kartki papieru jest trudne
do wykonania, ale zliczenie słów i wskazanie Tobie ile razy
zostało użyte najczęściej występujące słowo jest bardzo łatwe:

~~~~ {.python}
python words.py
Wprowadź plik: words.txt
w 5
~~~~

Nasz "osobisty asystent analizy informacji" szybko powiedział nam, że słowo
"w" został użyty pięć razy w pierwszych trzech akapitach tego rozdziału.

Właśnie ten fakt, że komputery są dobre w rzeczach, w których ludzie dobrzy 
nie są, jest powodem, dla którego musisz nauczyć się mówić "językiem
komputerowym". Gdy nauczysz się tego nowego języka, możesz przekazywać 
nieciekawe zadania swojemu partnerowi (komputerowi), pozostawiając sobie więcej
czasu na robienie rzeczy, do których jesteś wyjątkowo przystosowany. Wnosisz
kreatywność, intuicję i pomysłowość do tego duetu.

Kreatywność i motywacja
-----------------------

Chociaż ta książka nie jest przeznaczona dla profesjonalnych programistów, 
profesjonalne programowanie może być bardzo satysfakcjonującą pracą,
zarówno po kątem finansowym, jak i osobistym. Tworzenie przydatnych, eleganckich
i sprytnych programów, z których mogą korzystać inni, to bardzo kreatywne
zajęcie. Twój komputer lub smartfon zwykle zawiera wiele różnych programów od 
wielu różnych grup programistów, które konkurują o Twoją uwagę i 
zainteresowanie. Robią wszystko, co w ich mocy, aby spełnić Twoje potrzeby i 
zapewnić podczas ich używania najlepsze *user experience* (z ang. *doświadczenie
użytkownika*). W niektórych sytuacjach, gdy wybierasz oprogramowanie, 
programiści są bezpośrednio wynagradzani z powodu twojego wyboru.

Jeśli myślimy o programach jako o twórczym wyniku pracy grup programistów, 
to być może poniższy rysunek przedstawia bardziej racjonalną wersję naszego
smartfona:

![Programiści mówią do Ciebie](height=1.0in@../images/pda2)

Na razie naszą główną motywacją nie jest zarabianie pieniędzy ani zadowolenie 
użytkowników końcowych, ale raczej bardziej produktywne przetwarzanie danych i 
informacji, które napotkamy w naszym życiu. Na początku będziesz zarówno 
programistą, jak i końcowym użytkownikiem swoich programów. Gdy zdobędziesz 
umiejętności programisty, a programowanie stanie się dla ciebie bardziej
twórcze, twoje myśli mogą skierować się w stronę tworzenia programów dla innych
osób.

Architektura sprzętu kommputerowego
-----------------------------------

\index{hardware}
\index{hardware!architecture}

Zanim zaczniemy uczyć się języka, którym będziemy wydawać polecenia komputerom
aby tworzyły dla nas oprogramowanie, musimy doszkolić się trochę o tym jak 
budowane są komputery. Gdybyś rozebrał komputer lub smartfon i zajrzał głęboko
mu się przyjał, to znalazłbyś następujące części:

![Architektura sprzętowa](height=1.75in@../images/arch)

Ogólne definicje tych części są następujące:

-   *Procesor* (ang. *central processing unit*, CPU) to część komputera, która 
     została zbudowana tak, aby dosłownie mieć obsesję na punkcie pytania 
     "Co dalej?". Jeśli komputer ma moc 3,0 gigaherców, to oznacza to, że 
     procesor zapyta "Co dalej?" trzy miliardy razy na sekundę. Będziesz musiał 
     nauczyć się w jaki sposób szybko porozumiewać się, tak by nadążać 
     za procesorem.

-   *Pamięć główna* jest używana do przechowywania informacji, których procesor
    potrzebuje w pośpiechu. Pamięć główna jest prawie tak szybka jak procesor. 
    Jednakże informacje przechowywane w pamięci głównej znikają po wyłączeniu 
    komputera.

-   *Pamięć pomocnicza* jest również używana do przechowywania informacji, ale
    jest znacznie wolniejsza niż pamięć główna. Zaletą pamięci dodatkowej jest 
    to, że może przechowywać informacje nawet wtedy, gdy komputer nie jest 
    zasilany. Przykładami pamięci dodatkowej są dyski twarde lub pamięć flash
    (zwykle znajdująca się w pamięciach USB/pendrive i przenośnych odtwarzaczach
    muzycznych).

-   *Urządzenia wejścia i wyjścia* to po prostu nasz ekran, klawiatura, mysz, 
    mikrofon, głośnik, panel dotykowy itp. Są to wszystkie sposoby interakcji z 
    komputerem.

-   Obecnie większość komputerów ma również *połączenie sieciowe*, które 
    umożliwia pobieranie informacji przez sieć. Możemy myśleć o sieci jako o
    bardzo powolnym miejscu do przechowywania i pobierania danych, które nie 
    zawsze są dostępne. W pewnym sensie sieć jest wolniejszą i czasami zawodną 
    formą *pamięci pomocniczej*.

Chociaż większość szczegółów dotyczących działania tych komponentów najlepiej
pozostawić konstruktorom komputerów, dobrze jest mieć pewną terminologię, tak 
abyśmy mogli rozmawiać o tych różnych częściach komputera podczas pisania 
naszych programów.

Twoim zadaniem jako programisty jest wykorzystywanie i zarządzanie każdym z tych
zasobów w celu rozwiązania problemu i przeanalizowania danych uzyskanych podczas
rozwiązynia tego probelmu. Jako programista będziesz głównie "rozmawiać" z 
procesorem i mówić mu, co ma robić dalej. Czasami powiesz procesorowi aby 
użył pamięci głównej, pamięci pomocniczej, sieci lub urządzeń wejścia/wyjścia.

![Gdzie jesteś?](height=1.75in@../images/arch2)

Musisz być osobą, która odpowiada na pytanie procesora "Co dalej?". Jednakże 
byłoby bardzo niewygodne zmniejszenie Ciebie do 5 mm wysokości i włożenie do 
komputera tylko po to, abyś mógł wydawać polecenia trzy miliardy razy na 
sekundę. Zamiast tego musisz wcześniej zapisać swoje instrukcje. Zapisane 
instrukcje nazywamy *programem*, a czynność zapisywania tych instrukcji i 
doprowadzania ich do poprawnej formy nazywamy *programowaniem*.


Zrozumieć programowanie
-----------------------

W dalszej części książki postaramy się zmienić Cię w osobę biegłą w sztuce
programowania. Na końcu zostaniesz *programistą* - być może nie profesjonalnym 
programistą, ale przynajmniej będziesz posiadał umiejętności spojrzenia na
problem analizy danych/informacji oraz opracowania programu do rozwiązania
takiego problemu.

\index{problem solving}

W pewnym sensie, aby być programistą potrzebujesz dwóch umiejętności:

-   Po pierwsze, musisz znać język programowania (Python) - musisz znać 
    jego słownictwo i gramatykę. Musisz umieć poprawnie pisać słowa w tym nowym
    języku i umieć konstruować dobrze sformułowane "zdania".

-   Po drugie, musisz umieć "opowiadać historię". Pisząc opowiadanie, łączysz
    słowa i zdania, tak aby przekazać czytelnikowi jakąś ideę lub myśl. 
    Konstruowanie historii wymaga pewnej sztuki, ale umiejętność pisania 
    historii poprawia się poprzez pisanie i uzyskiwanie informacji zwrotnych. 
    W programowaniu nasz program jest "historią", a problem, który próbujesz 
    rozwiązać, to "idea/myśl".

Gdy nauczysz się jednego języka programowania (w tym przypadku Pythona), 
znacznie łatwiej będzie Ci nauczyć się drugiego języka programowania, takiego 
jak JavaScript lub C++. Nowy język programowania ma bardzo różne słownictwo i
gramatykę, ale umiejętności rozwiązywania problemów będą takie same we 
wszystkich językach programowania.

Dość szybko nauczysz się "słownictwa" i "zdań" w Pythonie. Napisanie spójnego
programu rozwiązującego zupełnie nowy problem zajmie trochę więcej czasu.
Uczymy programowania podobnie jak pisania. Zaczynamy czytać i objaśniać 
programy, potem piszemy proste programy, a potem z czasem piszemy coraz bardziej
złożone programy. W pewnym momencie "znajdziesz swoją muzę", sam zobaczysz 
pewne wzorce i w bardziej naturalny sposób zauważysz w jaki sposób podchodzić
do danego problemu i jak napisać program, który go rozwiązuje. A gdy już do tego
dojdziesz, programowanie stanie się bardzo przyjemną i twórczą czynnością.

Zaczniemy od słownictwa i struktury programów w języku Python. Bądź cierpliwy,
ponieważ proste przykłady przypomną ci moment w życiu gdy pierwszy raz zacząłeś
czytać.

Słowa i zdania
-------------------

\index{programming language}
\index{language!programming}

W przeciwieństwie do ludzkich języków, słownictwo Pythona jest w rzeczywistości
dość skromne. To "słownictwo" nazywamy "słowami zastrzeżonymi". Są to słowa, 
które mają dla Pythona szczególne znaczenie. Gdy Python widzi te słowa w 
programie napisanym w języku Python, to mają one jedno i tylko jedno znaczenie
dla Pythona. Później, podczas pisania programów, stworzysz własne słowa, które
dla ciebie mają jakieś znaczenie - będą to *zmienne*. Będziesz mieć dużą swobodę
w wyborze nazw dla swoich zmiennych, ale nie możesz używać żadnych zastrzeżonych
słów Pythona jako nazwy zmiennej.

Gdy trenujemy psa, używamy specjalnych słów, takich jak "siad", "zostań" i 
"aport". Kiedy rozmawiasz z psem i nie używasz żadnych zastrzeżonych słów,
to po prostu patrzy na ciebie z pytającym wyrazem twarzy, dopóki nie powiesz
zastrzeżonego słowa. Na przykład, jeśli powiesz: "chciałbym aby więcej ludzi
chodziło na spacer po to by poprawić ich ogólny stan zdrowia", większość psów 
prawdopodobnie usłyszy: "bla bla bla *spacer* bla bla bla bla". Dzieje się tak,
ponieważ "spacer" jest zarezerwowanym słowem w języku komunikacji z psami. 
Natomiast wiele wskazuje na to, że język komunikacji między ludźmi a kotami 
nie ma zastrzeżonych słów^[<http://xkcd.com/231/>].

Lista zastrzeżonych słów języka, w którym ludzie komunikują się z Pythonem,
zawiera następujące wyrazy:

    and       del       global      not       with
    as        elif      if          or        yield
    assert    else      import      pass      
    break     except    in          raise
    class     finally   is          return
    continue  for       lambda      try
    def       from      nonlocal    while    

To tyle, a dodatkowo w przeciwieństwie do psa, Python jest już w pełni 
wyszkolony. Kiedy powiesz "try", Python wykona polecenie "try" bezbłędnie 
za każdym razem gdy je wypowiesz.

W odpowiednim czasie poznamy powyższe zastrzeżone słówa oraz to kiedy ich 
używać, ale na razie skupimy się na odpowiedniku słowa "daj głos" w Pythonie
(w języku człowiek-pies). Dobrą rzeczą we wskazywaniu Pythonowi, że ma "dać
głos", jest to, że możemy mu nawet powiedzieć co ma powiedzieć, przekazując mu
wiadomość w cudzysłowie:

~~~~ {.python}
print('Witaj świecie!')
~~~~

I oto napisaliśmy w Pythonie nasze pierwsze poprawne składniowo zdanie. Nasze
zdanie zaczyna się od funkcji *print*, po której następuje ujęty w apostrofy 
ciąg wybranego przez nas tekstu. Ciągi tekstu w instrukcjach *print* są ujęte w
apostrofy lub cudzysłowy. Apostrofy i cudzysłowy robią to samo; większość ludzi
używa apostrofów z wyjątkiem przypadków, w których apostrof pojawia się w ciągu
tekstu.

Rozmawianie z Pythonem
----------------------

Teraz, gdy mamy już słowo i proste zdanie, które znamy w Pythonie, musimy 
wiedzieć w jaki sposób rozpocząć rozmowę z Pythonem, tak aby przetestować nasze
nowe umiejętności językowe.

Zanim będziesz mógł rozmawiać z Pythonem, musisz najpierw zainstalować na swoim
komputerze oprogramowanie Pythona oraz nauczyć się jak uruchomić Pythona na 
swoim komputerze. Jest to zbyt wiele szczegółów jak na ten rozdział, więc
sugeruję zajrzeć na stronę [www.py4e.com](http://www.py4e.com), gdzie umieściłem
szczegółowe instrukcje i zrzuty ekranu dotyczące konfiguracji i uruchamiania
Pythona w systemach komputerów Macintosh i Windows. W pewnym momencie znajdziesz
się w terminalu lub oknie wiersza poleceń i wpiszesz *python*, a interpreter
Pythona rozpocznie pracę w trybie interaktywnym i pojawi się mniej więcej
w następujący sposób:

\index{interactive mode}

~~~~ {.python}
Python 3.5.1 (v3.5.1:37a07cee5969, Dec  6 2015, 01:54:25)
[MSC v.1900 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more
information.
>>>
~~~~

Znak zachęty `>>>` jest sposobem zadawania Tobie pytań przez interpreter języka
Python "Co mam teraz zrobić?". Python jest teraz gotowy do rozmowy z tobą.
Wszystko co musisz teraz wiedzieć, to jak mówić w języku Pythona.

Powiedzmy na przykład, że nie znałeś nawet najprostszych słów lub zdań w języku
Pythona. Możesz użyć standardowego zwrotu, z którego korzystają astronauci gdy
lądują na odległej planecie i próbują rozmawiać z jej mieszkańcami:

~~~~ {.python}
>>> Przybywam w pokoju, zabierz mnie proszę do swojego przywódcy
File "<stdin>", line 1
    Przybywam w pokoju, zabierz mnie proszę do swojego przywódcy
              ^
SyntaxError: invalid syntax
>>>
~~~~

Nie idzie nam za dobrze. Jeśli nie wymyślisz czegoś szybko, mieszkańcy planety
prawdopodobnie dźgną cię włóczniami, rzucą na rożen, upieczą na ogniu i zjedzą
na obiad.

Na szczęście na czas podróży zabrałeś kopię tej książki, a następnie 
przewróciłeś kartki na tę stronę i spróbowałeś jeszcze raz:

~~~~ {.python}
>>> print('Witaj świecie!')
Witaj świecie!
~~~~

Wygląda to o wiele lepiej, więc spróbuj przekazać trochę więcej komunikatów:

~~~~ {.python}
>>> print('Musisz być legendarnym bogiem, który pochodzi z nieba')
Musisz być legendarnym bogiem, który pochodzi z nieba
>>> print('Czekaliśmy na Ciebie od dawna')
Czekaliśmy na Ciebie od dawna
>>> print('Nasza legenda mówi, że z musztardą będziesz bardzo smaczny')
Nasza legenda mówi, że z musztardą będziesz bardzo smaczny
>>> print 'Będziemy ucztować wieczorem, o ile nie powiesz
  File "<stdin>", line 1
    print 'Będziemy ucztować wieczorem, o ile nie powiesz
                                                         ^
SyntaxError: Missing parentheses in call to 'print'
>>>
~~~~

Przez jakiś czas rozmowa szła całkiem dobrze, ale potem popełniłeś malutki błąd
używając języka Python, a Python ponownie pokazał swoje pazury.

W tym miejscu powinieneś również zdać sobie sprawę, że podczas gdy Python jest
niesamowicie złożony i potężny oraz bardzo wybredny pod względem składni 
używanej do komunikacji z nim, Python *nie* jest inteligentny. Tak naprawdę po
prostu rozmawiasz ze sobą, ale używając odpowiedniej składni.

W pewnym sensie, kiedy używasz programu napisanego przez kogoś innego, to
rozmowa odbywa się między tobą a innymi programistami, gdzie Python działa jako
pośrednik. Python to sposób, dzięki któremu twórcy programów mogą wyrazić jak ma
przebiegać taka rozmowa. W kilku kolejnych rozdziałach będziesz jednym z tych
programistów używających Pythona do rozmów z użytkownikami twojego programu.

Zanim opuścimy naszą pierwszą rozmowę z interpreterem Pythona, prawdopodobnie
powinieneś znać właściwy sposób na "pożegnanie się" podczas interakcji z
mieszkańcami planety Python:

~~~~ {.python}
>>> do-zobaczenia
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'do' is not defined
>>> if you don't mind, I need to leave
  File "<stdin>", line 1
    if you don't mind, I need to leave
           ^
SyntaxError: invalid syntax
>>> quit()
~~~~

Możesz zauważyć, że błąd jest różny dla pierwszych dwóch niepoprawnych prób.
Drugi błąd jest inny, ponieważ *if* jest słowem zastrzeżonym, a Python zobaczył
to słowo i pomyślał, że próbujemy coś powiedzieć, ale składnia zdania była
błędna.

Właściwym sposobem "pożegnania się" z Pythonem jest wpisanie *quit()* za
interaktywnym znakiem zachęty `>>>`. Odgadnięcie tego pewnie zajęłoby ci trochę
czasu, więc posiadanie książki pod ręką prawdopodobnie okaże się pomocne.

Terminology: Interpreter and compiler
-------------------------------------

Python is a *high-level* language intended to be
relatively straightforward for humans to read and write and for
computers to read and process. Other high-level languages include Java,
C++, PHP, Ruby, Basic, Perl, JavaScript, and many more. The actual
hardware inside the Central Processing Unit (CPU) does not understand
any of these high-level languages.

The CPU understands a language we call *machine
language*. Machine language is very simple and frankly very
tiresome to write because it is represented all in zeros and ones:

~~~~
001010001110100100101010000001111
11100110000011101010010101101101
...
~~~~

Machine language seems quite simple on the surface, given that there are
only zeros and ones, but its syntax is even more complex and far more
intricate than Python. So very few programmers ever write machine
language. Instead we build various translators to allow programmers to
write in high-level languages like Python or JavaScript and these
translators convert the programs to machine language for actual
execution by the CPU.

Since machine language is tied to the computer hardware, machine
language is not *portable* across different types of
hardware. Programs written in high-level languages can be moved between
different computers by using a different interpreter on the new machine
or recompiling the code to create a machine language version of the
program for the new machine.

These programming language translators fall into two general categories:
(1) interpreters and (2) compilers.

An *interpreter* reads the source code of the program as
written by the programmer, parses the source code, and interprets the
instructions on the fly. Python is an interpreter and when we are
running Python interactively, we can type a line of Python (a sentence)
and Python processes it immediately and is ready for us to type another
line of Python.

Some of the lines of Python tell Python that you want it to remember
some value for later. We need to pick a name for that value to be
remembered and we can use that symbolic name to retrieve the value
later. We use the term *variable* to refer to the labels
we use to refer to this stored data.

~~~~ {.python}
>>> x = 6
>>> print(x)
6
>>> y = x * 7
>>> print(y)
42
>>>
~~~~

In this example, we ask Python to remember the value six and use the
label *x* so we can retrieve the value later. We verify
that Python has actually remembered the value using
*print*. Then we ask Python to retrieve
*x* and multiply it by seven and put the newly computed
value in *y*. Then we ask Python to print out the value
currently in *y*.

Even though we are typing these commands into Python one line at a time,
Python is treating them as an ordered sequence of statements with later
statements able to retrieve data created in earlier statements. We are
writing our first simple paragraph with four sentences in a logical and
meaningful order.

It is the nature of an *interpreter* to be able to have
an interactive conversation as shown above. A *compiler*
needs to be handed the entire program in a file, and then it runs a
process to translate the high-level source code into machine language
and then the compiler puts the resulting machine language into a file
for later execution.

If you have a Windows system, often these executable machine language
programs have a suffix of ".exe" or ".dll" which stand for "executable"
and "dynamic link library" respectively. In Linux and Macintosh, there
is no suffix that uniquely marks a file as executable.

If you were to open an executable file in a text editor, it would look
completely crazy and be unreadable:

~~~~
^?ELF^A^A^A^@^@^@^@^@^@^@^@^@^B^@^C^@^A^@^@^@\xa0\x82
^D^H4^@^@^@\x90^]^@^@^@^@^@^@4^@ ^@^G^@(^@$^@!^@^F^@
^@^@4^@^@^@4\x80^D^H4\x80^D^H\xe0^@^@^@\xe0^@^@^@^E
^@^@^@^D^@^@^@^C^@^@^@^T^A^@^@^T\x81^D^H^T\x81^D^H^S
^@^@^@^S^@^@^@^D^@^@^@^A^@^@^@^A\^D^HQVhT\x83^D^H\xe8
....
~~~~

It is not easy to read or write machine language, so it is nice that we
have *interpreters* and *compilers* that
allow us to write in high-level languages like Python or C.

Now at this point in our discussion of compilers and interpreters, you
should be wondering a bit about the Python interpreter itself. What
language is it written in? Is it written in a compiled language? When we
type "python", what exactly is happening?

The Python interpreter is written in a high-level language called "C".
You can look at the actual source code for the Python interpreter by
going to [www.python.org](http://www.python.org) and working your way to their
source code. So Python is a program itself and it is compiled into
machine code. When you installed Python on your computer (or the vendor
installed it), you copied a machine-code copy of the translated Python
program onto your system. In Windows, the executable machine code for
Python itself is likely in a file with a name like:

~~~~
C:\Python35\python.exe
~~~~

That is more than you really need to know to be a Python programmer, but
sometimes it pays to answer those little nagging questions right at the
beginning.

Writing a program
-----------------

Typing commands into the Python interpreter is a great way to experiment
with Python's features, but it is not recommended for solving more
complex problems.

When we want to write a program, we use a text editor to write the
Python instructions into a file, which is called a
*script*. By convention, Python scripts have names that
end with `.py`.

\index{script}

To execute the script, you have to tell the Python interpreter the name
of the file. In a command window, you would type
`python hello.py` as follows:

~~~~ {.bash}
$ cat hello.py
print('Hello world!')
$ python hello.py
Hello world!
~~~~

The "\$" is the operating system prompt, and the "cat hello.py" is
showing us that the file "hello.py" has a one-line Python program to
print a string.

We call the Python interpreter and tell it to read its source code from
the file "hello.py" instead of prompting us for lines of Python code
interactively.

You will notice that there was no need to have *quit()*
at the end of the Python program in the file. When Python is reading
your source code from a file, it knows to stop when it reaches the end
of the file.

What is a program?
------------------

The definition of a *program* at its most basic is a
sequence of Python statements that have been crafted to do something.
Even our simple *hello.py* script is a program. It is a
one-line program and is not particularly useful, but in the strictest
definition, it is a Python program.

It might be easiest to understand what a program is by thinking about a
problem that a program might be built to solve, and then looking at a
program that would solve that problem.

Lets say you are doing Social Computing research on Facebook posts and
you are interested in the most frequently used word in a series of
posts. You could print out the stream of Facebook posts and pore over
the text looking for the most common word, but that would take a long
time and be very mistake prone. You would be smart to write a Python
program to handle the task quickly and accurately so you can spend the
weekend doing something fun.

For example, look at the following text about a clown and a car. Look at
the text and figure out the most common word and how many times it
occurs.

~~~~
the clown ran after the car and the car ran into the tent
and the tent fell down on the clown and the car
~~~~

Then imagine that you are doing this task looking at millions of lines
of text. Frankly it would be quicker for you to learn Python and write a
Python program to count the words than it would be to manually scan the
words.

The even better news is that I already came up with a simple program to
find the most common word in a text file. I wrote it, tested it, and now
I am giving it to you to use so you can save some time.

\VerbatimInput{../code3/words.py}
\begin{trinketfiles}
../code3/words.txt
\end{trinketfiles}

You don't even need to know Python to use this program. You will need to
get through Chapter 10 of this book to fully understand the awesome
Python techniques that were used to make the program. You are the end
user, you simply use the program and marvel at its cleverness and how it
saved you so much manual effort. You simply type the code into a file
called *words.py* and run it or you download the source
code from <http://www.py4e.com/code3/> and run it.

\index{program}

This is a good example of how Python and the Python language are acting
as an intermediary between you (the end user) and me (the programmer).
Python is a way for us to exchange useful instruction sequences (i.e.,
programs) in a common language that can be used by anyone who installs
Python on their computer. So neither of us are talking *to
Python*, instead we are communicating with each other
*through* Python.

The building blocks of programs
-------------------------------

In the next few chapters, we will learn more about the vocabulary,
sentence structure, paragraph structure, and story structure of Python.
We will learn about the powerful capabilities of Python and how to
compose those capabilities together to create useful programs.

There are some low-level conceptual patterns that we use to construct
programs. These constructs are not just for Python programs, they are
part of every programming language from machine language up to the
high-level languages.

input
:   Get data from the "outside world". This might be reading data from a
    file, or even some kind of sensor like a microphone or GPS. In our
    initial programs, our input will come from the user typing data on
    the keyboard.

output
:   Display the results of the program on a screen or store them in a
    file or perhaps write them to a device like a speaker to play music
    or speak text.

sequential execution
:   Perform statements one after another in the order they are
    encountered in the script.

conditional execution
:   Check for certain conditions and then execute or skip a sequence of
    statements.

repeated execution
:   Perform some set of statements repeatedly, usually with some
    variation.

reuse
:   Write a set of instructions once and give them a name and then reuse
    those instructions as needed throughout your program.

It sounds almost too simple to be true, and of course it is never so
simple. It is like saying that walking is simply "putting one foot in
front of the other". The "art" of writing a program is composing and
weaving these basic elements together many times over to produce
something that is useful to its users.

The word counting program above directly uses all of these patterns
except for one.

What could possibly go wrong?
-----------------------------

As we saw in our earliest conversations with Python, we must communicate
very precisely when we write Python code. The smallest deviation or
mistake will cause Python to give up looking at your program.

Beginning programmers often take the fact that Python leaves no room for
errors as evidence that Python is mean, hateful, and cruel. While Python
seems to like everyone else, Python knows them personally and holds a
grudge against them. Because of this grudge, Python takes our perfectly
written programs and rejects them as "unfit" just to torment us.

~~~~ {.python}
>>> primt 'Hello world!'
File "<stdin>", line 1
  primt 'Hello world!'
                     ^
SyntaxError: invalid syntax
>>> primt ('Hello world')
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
NameError: name 'primt' is not defined

>>> I hate you Python!
File "<stdin>", line 1
  I hate you Python!
       ^
SyntaxError: invalid syntax
>>> if you come out of there, I would teach you a lesson
File "<stdin>", line 1
  if you come out of there, I would teach you a lesson
            ^
SyntaxError: invalid syntax
>>>
~~~~

There is little to be gained by arguing with Python. It is just a tool.
It has no emotions and it is happy and ready to serve you whenever you
need it. Its error messages sound harsh, but they are just Python's call
for help. It has looked at what you typed, and it simply cannot
understand what you have entered.

Python is much more like a dog, loving you unconditionally, having a few
key words that it understands, looking you with a sweet look on its face
(`>>>`), and waiting for you to say something it
understands. When Python says "SyntaxError: invalid syntax", it is
simply wagging its tail and saying, "You seemed to say something but I
just don't understand what you meant, but please keep talking to me
(`>>>`)."

As your programs become increasingly sophisticated, you will encounter
three general types of errors:

Syntax errors
:   These are the first errors you will make and the easiest to fix. A
    syntax error means that you have violated the "grammar" rules of
    Python. Python does its best to point right at the line and
    character where it noticed it was confused. The only tricky bit of
    syntax errors is that sometimes the mistake that needs fixing is
    actually earlier in the program than where Python
    *noticed* it was confused. So the line and character
    that Python indicates in a syntax error may just be a starting point
    for your investigation.

Logic errors
:   A logic error is when your program has good syntax but there is a
    mistake in the order of the statements or perhaps a mistake in how
    the statements relate to one another. A good example of a logic
    error might be, "take a drink from your water bottle, put it in your
    backpack, walk to the library, and then put the top back on the
    bottle."

Semantic errors
:   A semantic error is when your description of the steps to take is
    syntactically perfect and in the right order, but there is simply a
    mistake in the program. The program is perfectly correct but it does
    not do what you *intended* for it to do. A simple
    example would be if you were giving a person directions to a
    restaurant and said, "...when you reach the intersection with the
    gas station, turn left and go one mile and the restaurant is a red
    building on your left." Your friend is very late and calls you to
    tell you that they are on a farm and walking around behind a barn,
    with no sign of a restaurant. Then you say "did you turn left or
    right at the gas station?" and they say, "I followed your directions
    perfectly, I have them written down, it says turn left and go one
    mile at the gas station." Then you say, "I am very sorry, because
    while my instructions were syntactically correct, they sadly
    contained a small but undetected semantic error.".

Again in all three types of errors, Python is merely trying its hardest
to do exactly what you have asked.

Debugging
---------

\index{debugging}

When Python spits out an error or even when it gives you a result that is different from what you had intended, then begins the hunt for the cause of the error. Debugging is the process of finding the cause of the error in your code. When you are debugging a program, and especially if you are working on a hard bug, there are four things to try:

reading
:   Examine your code, read it back to yourself, and check that it says
    what you meant to say.

running
:   Experiment by making changes and running different versions. Often
    if you display the right thing at the right place in the program,
    the problem becomes obvious, but sometimes you have to spend some
    time to build scaffolding.

ruminating
:   Take some time to think! What kind of error is it: syntax, runtime,
    semantic? What information can you get from the error messages, or
    from the output of the program? What kind of error could cause the
    problem you're seeing? What did you change last, before the problem
    appeared?

retreating
:   At some point, the best thing to do is back off, undoing recent
    changes, until you get back to a program that works and that you
    understand. Then you can start rebuilding.

Beginning programmers sometimes get stuck on one of these activities and
forget the others.  Finding a hard bug requires reading, running, ruminating, and sometimes retreating. If you get stuck on one of these activities, try the others. Each activity comes with its own failure mode.

\index{typographical error}

For example, reading your code might help if the problem is a
typographical error, but not if the problem is a conceptual
misunderstanding. If you don't understand what your program does, you
can read it 100 times and never see the error, because the error is in
your head.

\index{experimental debugging}

Running experiments can help, especially if you run small, simple tests.
But if you run experiments without thinking or reading your code, you
might fall into a pattern I call "random walk programming", which is the
process of making random changes until the program does the right thing.
Needless to say, random walk programming can take a long time.

\index{random walk programming}
\index{development plan!random walk programming}

You have to take time to think. Debugging is like an experimental
science. You should have at least one hypothesis about what the problem
is. If there are two or more possibilities, try to think of a test that
would eliminate one of them.

Taking a break helps with the thinking. So does talking. If you explain
the problem to someone else (or even to yourself), you will sometimes
find the answer before you finish asking the question.

But even the best debugging techniques will fail if there are too many
errors, or if the code you are trying to fix is too big and complicated.
Sometimes the best option is to retreat, simplifying the program until
you get to something that works and that you understand.

Beginning programmers are often reluctant to retreat because they can't
stand to delete a line of code (even if it's wrong). If it makes you
feel better, copy your program into another file before you start
stripping it down. Then you can paste the pieces back in a little bit at
a time.

The learning journey
--------------------

As you progress through the rest of the book, don't be afraid if the
concepts don't seem to fit together well the first time. When you were
learning to speak, it was not a problem for your first few years that
you just made cute gurgling noises. And it was OK if it took six months
for you to move from simple vocabulary to simple sentences and took 5-6
more years to move from sentences to paragraphs, and a few more years to
be able to write an interesting complete short story on your own.

We want you to learn Python much more rapidly, so we teach it all at the
same time over the next few chapters. But it is like learning a new
language that takes time to absorb and understand before it feels
natural. That leads to some confusion as we visit and revisit topics to
try to get you to see the big picture while we are defining the tiny
fragments that make up that big picture. While the book is written
linearly, and if you are taking a course it will progress in a linear
fashion, don't hesitate to be very nonlinear in how you approach the
material. Look forwards and backwards and read with a light touch. By
skimming more advanced material without fully understanding the details,
you can get a better understanding of the "why?" of programming. By
reviewing previous material and even redoing earlier exercises, you will
realize that you actually learned a lot of material even if the material
you are currently staring at seems a bit impenetrable.

Usually when you are learning your first programming language, there are
a few wonderful "Ah Hah!" moments where you can look up from pounding
away at some rock with a hammer and chisel and step away and see that
you are indeed building a beautiful sculpture.

If something seems particularly hard, there is usually no value in
staying up all night and staring at it. Take a break, take a nap, have a
snack, explain what you are having a problem with to someone (or perhaps
your dog), and then come back to it with fresh eyes. I assure you that
once you learn the programming concepts in the book you will look back
and see that it was all really easy and elegant and it simply took you a
bit of time to absorb it.

Glossary
--------

bug
:   An error in a program.
\index{bug}

central processing unit
:   The heart of any computer. It is what runs the software that we
    write; also called "CPU" or "the processor".
\index{central processing unit}
\index{CPU}

compile
:   To translate a program written in a high-level language into a
    low-level language all at once, in preparation for later execution.
\index{compile}

high-level language
:   A programming language like Python that is designed to be easy for
    humans to read and write.
\index{high-level language}

interactive mode
:   A way of using the Python interpreter by typing commands and
    expressions at the prompt.
\index{interactive mode}

interpret
:   To execute a program in a high-level language by translating it one
    line at a time.
\index{interpret}

low-level language
:   A programming language that is designed to be easy for a computer to
    execute; also called "machine code" or "assembly language".
\index{low-level language}

machine code
:   The lowest-level language for software, which is the language that
    is directly executed by the central processing unit (CPU).
\index{machine code}

main memory
:   Stores programs and data. Main memory loses its information when the
    power is turned off.
\index{main memory}

parse
:   To examine a program and analyze the syntactic structure.
\index{parse}

portability
:   A property of a program that can run on more than one kind of
    computer.
\index{portability}

print function
:   An instruction that causes the Python interpreter to display a value
    on the screen.
\index{print function}
\index{function!print}

problem solving
:   The process of formulating a problem, finding a solution, and
    expressing the solution.
\index{problem solving}

program
:   A set of instructions that specifies a computation.
\index{program}

prompt
:   When a program displays a message and pauses for the user to type
    some input to the program.
\index{prompt}

secondary memory
:   Stores programs and data and retains its information even when the
    power is turned off. Generally slower than main memory. Examples of
    secondary memory include disk drives and flash memory in USB sticks.
\index{secondary memory}

semantics
:   The meaning of a program.
\index{semantics}

semantic error
:   An error in a program that makes it do something other than what the
    programmer intended.
\index{semantic error}

source code
:   A program in a high-level language.
\index{source code}

Exercises
---------

**Exercise 1: What is the function of the secondary memory in a computer?**

a\) Execute all of the computation and logic of the program\
b) Retrieve web pages over the Internet\
c) Store information for the long term, even beyond a power cycle\
d) Take input from the user

**Exercise 2: What is a program?**

**Exercise 3: What is the difference between a compiler and an
interpreter?**

**Exercise 4: Which of the following contains "machine code"?**

a\) The Python interpreter\
b) The keyboard\
c) Python source file\
d) A word processing document

**Exercise 5: What is wrong with the following code:**

~~~~ {.python}
>>> primt 'Hello world!'
File "<stdin>", line 1
  primt 'Hello world!'
                     ^
SyntaxError: invalid syntax
>>>
~~~~

**Exercise 6: Where in the computer is a variable such as "x" stored after
the following Python line finishes?**

~~~~ {.python}
x = 123
~~~~

a\) Central processing unit\
b) Main Memory\
c) Secondary Memory\
d) Input Devices\
e) Output Devices

**Exercise 7: What will the following program print out:**

~~~~ {.python}
x = 43
x = x + 1
print(x)
~~~~

a\) 43\
b) 44\
c) x + 1\
d) Error because x = x + 1 is not possible mathematically

**Exercise 8: Explain each of the following using an example of a human
capability: (1) Central processing unit, (2) Main Memory, (3) Secondary
Memory, (4) Input Device, and (5) Output Device. For example, "What is
the human equivalent to a Central Processing Unit"?**

**Exercise 9: How do you fix a "Syntax Error"?**

