Listy
=====

\index{list}
\index{type!list}

Lista jest sekwencją
--------------------

Podobnie jak ciąg znaków, *lista* jest sekwencją wartości. W ciągu znaku, wartości są znakami, natomiast w liście mogą być dowolnego typu. Wartości występujące w liście są nazywane *elementami*, z rzadka *pozycjami*.

\index{element}
\index{sequence}
\index{item}

Istnieje kilka sposobów na stworzenie nowej listy; najprostszym jest umieszczenie elementów w nawiasach kwadratowych ("[" i "]"):

~~~~ {.python}
[10, 20, 30, 40]
['chrupiąca żabka', 'pęcherz barana', 'paw skowronka']
~~~~

Pierwszym przykładem jest lista składająca się z czterech liczb całkowitych. Drugi przykład to lista trzech ciągów znaków. Elementy listy nie muszą być tego samego typu. Poniższa lista zawiera ciąg znaków, liczbę zmiennoprzecinkową, liczbę całkowitą i (uwaga!) inną listę:

~~~~ {.python}
['spam', 2.0, 5, [10, 20]]
~~~~ 

Gdy jedna lista znajduje się w innej liście, to mówimy, że jest *zagnieżdżona*.

\index{nested list}
\index{list!nested}

Lista, która nie zawiera żadnych elementów, nazywana jest listą pustą. Możesz utworzyć taką listę używając pustych nawiasów kwadratowych, tj. `[]`.

\index{empty list}
\index{list!empty}

Jak pewnie się spodziewałeś, możesz przypisać wartości listy do zmiennych:

~~~~ {.python .trinket}
>>> cheeses = ['Cheddar', 'Edam', 'Gouda']
>>> numbers = [17, 123]
>>> empty = []
>>> print(cheeses, numbers, empty)
['Cheddar', 'Edam', 'Gouda'] [17, 123] []
~~~~

\index{assignment}

Listy są zmienne
-----------------

\index{list!element}
\index{access}
\index{index}
\index{}
\index{bracket operator}
\index{operator!bracket}

Składnia dostępu do elementów listy jest taka sama jak w przypadku dostępu do znaków w napisach: używa się operatora nawiasów kwadratowych. Wyrażenie wewnątrz nawiasów określa indeks. Pamiętaj, że indeksy zaczynają się od 0:

~~~~ {.python}
>>> print(cheeses[0])
Cheddar
~~~~

W odróżnieniu od ciągów znaków, listy są zmienne, ponieważ możesz zmienić kolejność elementów na liście lub ponownie przypisać jakiś element do listy. Kiedy operator nawiasów pojawia się po lewej stronie przypisania, identyfikuje on pozycję listy, do której zostanie coś przypisane.

\index{mutability}

~~~~ {.python .trinket}
>>> numbers = [17, 123]
>>> numbers[1] = 5
>>> print(numbers)
[17, 5]
~~~~

Pierwszym elementem `numbers`, który kiedyś wynosił 123, jest teraz 5.

\index{index!starting at zero}
\index{zero, index starting at}

Możesz myśleć o liście jako o relacji między indeksami i elementami. Ta relacja nazywana jest *mapowaniem*; każdy indeks "mapuje" do jednego z elementów.

\index{item assignment}
\index{assignment!item}

Indeksy listy działają tak samo jak indeksy ciągów znaków:

-   Każde wyrażenie będące liczbą całkowitą może być użyte jako indeks.

-   Jeśli spróbujesz odczytać lub zapisać pozycję, która nie istnieje, otrzymasz `IndexError`.

\index{exception!IndexError}
\index{IndexError}

-   Jeśli indeks ma wartość ujemną, to oblicza się go wstecz od końca listy.

\index{list!index}
\index{list!membership}
\index{membership!list}
\index{in operator}
\index{operator!in}

Operator `in` działa również na listach.

~~~~ {.python .trinket}
>>> cheeses = ['Cheddar', 'Edam', 'Gouda']
>>> 'Edam' in cheeses
True
>>> 'Brie' in cheeses
False
~~~~

Poruszanie się po listach
-------------------------

\index{list!traversal}
\index{traversal!list}
\index{for loop}
\index{loop!for}
\index{statement!for}

Najczęstszym sposobem na przejście po elementach listy jest pętla `for`. Składnia jest taka sama jak dla ciągów znaków:

~~~~ {.python}
for cheese in cheeses:
    print(cheese)
~~~~

Jest to dobre rozwiązanie jeśli musisz tylko odczytać elementy z listy. Ale jeśli chcesz coś w niej dopisać lub zaktualizować, to potrzebujesz indeksów. W takiej sytuacji najczęściej wykorzystuje się połączenie funkcji `range` i `len`:

\index{looping!with indices}
\index{index!looping with}

~~~~ {.python}
for i in range(len(numbers)):
    numbers[i] = numbers[i] * 2
~~~~

Powyższa pętla przechodzi przez listę i aktualizuje każdy element. `len` zwraca liczbę elementów na liście. `range` zwraca listę indeksów od 0 do $n-1$, gdzie $n$ jest długością listy. Przy każdej iteracji pętli, `i` kolejno uzyskuje indeks elementu. Instrukcja przypisania w ciele pętli używa `i` do odczytania starej wartości elementu i przypisania nowej wartości.

\index{item update}
\index{update!item}

Pętla `for` przechodząca przez pustą listę nigdy nie wykonuje ciała pętli:

~~~~ {.python}
empty = []
for x in empty:
    print('Nikt tego nigdy nie zobaczy.')
~~~~

Chociaż lista może zawierać inną listę, to zagnieżdżona lista nadal liczy się jako pojedynczy element. Długość poniższej listy wynosi cztery:

\index{nested list}
\index{list!nested}

~~~~ {.python}
['spam', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]
~~~~

Operacje na listach
-------------------

\index{list!operation}

Operator `+` konkatenuje (łączy) listy:

\index{concatenation!list}
\index{list!concatenation}

~~~~ {.python .trinket}
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> c = a + b
>>> print(c)
[1, 2, 3, 4, 5, 6]
~~~~

Z kolei operator `*` powtarza listę określoną liczbę razy:

\index{repetition!list}
\index{list!repetition}

~~~~ {.python .trinket}
>>> [0] * 4
[0, 0, 0, 0]
>>> [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
~~~~

W pierwszym przykładzie lista jest powtórzona cztery razy. Drugi przykład powtarza listę trzy razy.

Wycinki list
------------

\index{slice operator}
\index{operator!slice}
\index{index!slice}
\index{list!slice}
\index{slice!list}

Operator wycinania działa również na listach:

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> t[1:3]
['b', 'c']
>>> t[:4]
['a', 'b', 'c', 'd']
>>> t[3:]
['d', 'e', 'f']
~~~~

Jeśli pominiesz pierwszy indeks, wycinek zaczyna się od początku listy. Jeśli pominiesz drugi indeks, wycinek idzie aż do końca. Zatem jeśli pominiesz oba, wycinek jest kopią całej listy.

\index{list!copy}
\index{slice!copy}
\index{copy!slice}

~~~~ {.python}
>>> t[:]
['a', 'b', 'c', 'd', 'e', 'f']
~~~~

Ponieważ listy są zmienne, często przydatne jest wykonanie kopii przed wykonaniem innych operacji, które wywracają ich zawartość do góry nogami.

\index{mutability}

Operator wycinania zastosowany po lewej stronie instrukcji przypisania może aktualizować wiele elementów:

\index{slice!update}
\index{update!slice}

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> t[1:3] = ['x', 'y']
>>> print(t)
['a', 'x', 'y', 'd', 'e', 'f']
~~~~

Metody obiektów będących listami
--------------------------------

\index{list!method}
\index{method, list}

Python udostępnia metody, które działają na listach. Na przykład, `append` dodaje nowy element na końcu listy:

\index{append method}
\index{method!append}

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c']
>>> t.append('d')
>>> print(t)
['a', 'b', 'c', 'd']
~~~~

`extend` działa podobnie, z tym że przyjmuje jako argument listę elementów do dopisania:

\index{extend method}
\index{method!extend}

~~~~ {.python .trinket}
>>> t1 = ['a', 'b', 'c']
>>> t2 = ['d', 'e']
>>> t1.extend(t2)
>>> print(t1)
['a', 'b', 'c', 'd', 'e']
~~~~

W powyższym przykładzie lsita `t2` pozostaje niezmieniona.

`sort` układa elementy listy od najmniejszego do największego:

\index{sort method}
\index{method!sort}

~~~~ {.python .trinket}
>>> t = ['d', 'c', 'e', 'b', 'a']
>>> t.sort()
>>> print(t)
['a', 'b', 'c', 'd', 'e']
~~~~

Większość metod listowych nie zwraca żadnej konkretnej wartości; modyfikują one listę i zwracają `None`. Tego typu modyfikacja nazywana jest *modyfikacją w miejscu*. Jeśli przypadkowo napiszesz `t = t.sort()`, zapewne będziesz zawiedziony zwróconym wynikiem.

\index{void method}
\index{method!void}
\index{inplace modification}
\index{None special value}
\index{special value!None}

Usuwanie elementów
------------------

\index{element deletion}
\index{deletion, element of list}

Istnieje kilka sposobów na usunięcie elementów z listy. Jeśli znasz indeks elementu, który chcesz usunąć, to możesz użyć metody `pop`:

\index{pop method}
\index{method!pop}

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c']
>>> x = t.pop(1)
>>> print(t)
['a', 'c']
>>> print(x)
b
~~~~

`pop` modyfikuje listę i zwraca element, który został usunięty. Jeśli nie podasz indeksu, to usunie on i zwróci ostatni element listy.

Jeśli nie potrzebujesz usuniętej wartości, możesz użyć operatora `del`:

\index{del operator}
\index{operator!del}

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c']
>>> del t[1]
>>> print(t)
['a', 'c']
~~~~

Jeśli znasz element, który chcesz usunąć (ale nie jego indeks), możesz użyć `remove`:

\index{remove method}
\index{method!remove}

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c']
>>> t.remove('b')
>>> print(t)
['a', 'c']
~~~~

Wartością zwracaną przez `remove` jest `None`.

\index{None special value}
\index{special value!None}

Aby usunąć więcej niż jeden element, możesz użyć `del` z indeksami podanymi w postaci wycinka:

~~~~ {.python .trinket}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> del t[1:5]
>>> print(t)
['a', 'f']
~~~~

Jak zwykle, wycinek wybiera wszystkie elementy aż do drugiego indeksu, ale wyłączając z tego ostatnią pozycję.

Listy i funkcje
---------------

Istnieje szereg wbudowanych funkcji, które mogą być używane na listach i które pozwalają na szybkie przeglądanie listy bez konieczności pisania własnych pętli:

~~~~ {.python .trinket}
>>> nums = [3, 41, 12, 9, 74, 15]
>>> print(len(nums))
6
>>> print(max(nums))
74
>>> print(min(nums))
3
>>> print(sum(nums))
154
>>> print(sum(nums)/len(nums))
25
~~~~

Funkcja `sum()` działa tylko wtedy, gdy elementy listy są liczbami. Pozostałe funkcje (`max()`, `len()` itp.) działają z listami ciągów znaków i innych typów, które mogą być porównywane.

Moglibyśmy przepisać nasz wcześniejszy program, który teraz obliczyłby średnią z liczb podanych przez użytkownika za pomocą listy.

Poniżej mamy program, który liczy średnią bez listy:

\VerbatimInput{../code3/avenum.py}

W powyższym programie mamy zmienne `count` i `total`, tak aby podczas kolejnych próśb o wprowadzenie danych pamiętać ile już wprowadzono liczb oraz by przechowywać sumę bieżącą wprowadzonych liczb.

W alternatywnym podejściu, możemy po prostu zapamiętać każdą wprowadzoną liczbę i pod koniec użyć wbudowanych funkcji do obliczenia sumy i zliczenia elementów.

\VerbatimInput{../code3/avelist.py}

Przed rozpoczęciem pętli tworzymy pustą listę, a następnie za każdym razem, gdy otrzymamy nową liczbę, dołączamy ją do listy. Na końcu programu po prostu obliczamy sumę liczb występujących na liście i dzielimy ją przez liczbę elementów listy, tak aby uzyskać średnią.

Listy i ciągi znaków
--------------------

\index{list}
\index{string}
\index{sequence}

Ciąg znaków jest sekwencją znaków, a lista jest sekwencją wartości, ale lista znaków nie jest tym samym co ciąg znaków. Aby przekonwertować ciąg znaków na listę znaków, możesz użyć funkcji `list`:

\index{list!function}
\index{function!list}

~~~~ {.python .trinket}
>>> s = 'spam'
>>> t = list(s)
>>> print(t)
['s', 'p', 'a', 'm']
~~~~

Ponieważ `list` jest nazwą wbudowanej funkcji, powinieneś unikać używania jej jako nazwy zmiennej. Unikam również litery "l", ponieważ w wyglądzie jest zbyt podobna do liczby "1". Właśnie dlatego używam "t".

Funkcja `list` rozbija ciąg znaków na pojedyncze litery. Jeśli chcesz rozbić ciąg znaków na słowa, to możesz użyć metody `split`:

\index{split method}
\index{method!split}

~~~~ {.python .trinket}
>>> s = 'usycham z tęsknoty za fiordami'
>>> t = s.split()
>>> print(t)
['usycham', 'z', 'tęsknoty', 'za', 'fiordami']
>>> print(t[2])
tęsknoty
~~~~

Gdy już użyjesz `split` aby rozbić ciąg znaków na listę słów, możesz użyć operatora indeksu (nawias kwadratowy) aby przyjrzeć się konkretnemu słowu na liście.

Możesz wywołać `split` z opcjonalnym argumentem zwanym *separatorem*, który określa jakie znaki mają być użyte do określania granic słów. Poniższy przykład używa myślnika jako separatora:

\index{optional argument}
\index{argument!optional}
\index{delimiter}

~~~~ {.python .trinket}
>>> s = 'spam-spam-spam'
>>> delimiter = '-'
>>> s.split(delimiter)
['spam', 'spam', 'spam']
~~~~

Funkcja `join` jest odwrotnością `split`. Przyjmuje ona listę ciągów znaków i konkatenuje jej elementy. `join` jest metodą obiektów będących ciągami znaków, więc musisz wywołać ją na separatorze i przekazać listę jako argument:

\index{join method}
\index{method!join}
\index{concatenation}

~~~~ {.python .trinket}
>>> t = ['usycham', 'z', 'tęsknoty', 'za', 'fiordami']
>>> delimiter = ' '
>>> delimiter.join(t)
'usycham z tęsknoty za fiordami'
~~~~

W tym przypadku separator jest znakiem spacji, więc `join` umieszcza spację między słowami. Aby połączyć ciągi znaków bez spacji, możesz użyć pustego ciągu znaków, "", jako separator.

\index{empty string}
\index{string!empty}

Parsowanie linii
----------------

Zwykle gdy czytamy z pliku, chcemy zrobić coś innego niż tylko wyświetlić całą linię. Często chcemy znaleźć "interesujące linie", a następnie *rozdzielić* linię, tak aby później znaleźć jakąś interesującą *część* tej linii. Co by było gdybyśmy chcieli wyświetlić dzień tygodnia z tych linii, które zaczynają się od "From "?

~~~~
From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008
~~~~

Metoda `split` jest bardzo skuteczna gdy ma do czynienia z tego rodzaju problemem. Możemy napisać mały program, który szuka linii zaczynających się od "From ", rozdzielić te linie przy pomocy `split`, a następnie wyświetlić trzecie słowo występujące w danej linii:

\VerbatimInput{../code3/search5.py}
\begin{trinketfiles}
../code3/mbox-short.txt
\end{trinketfiles}

Program generuje następujące wyjście:

    Sat
    Fri
    Fri
    Fri
    ...

Później poznamy coraz bardziej wyrafinowane techniki wybierania linii do dalszego przetwarzania oraz dowiemy się jak je przeanalizować, tak aby znaleźć dokładnie ten fragment informacji, którego szukamy.

Obiekty i wartości
------------------

\index{object}
\index{value}

Jeśli wykonamy poniższe instrukcje przypisania:

~~~~ {.python}
a = 'banan'
b = 'banan'
~~~~

to wiemy, że zarówno `a`, jak i `b` odnoszą się do ciągu znaków, ale nie wiemy, czy odnoszą się one do *tego samego* ciągu znaków. Istnieją dwa możliwe stany:

\index{aliasing}

![Zmienne i obiekty](height=0.5in@../images/list1)

W jednym przypadku, `a` i `b` odnoszą się do dwóch różnych obiektów, które mają tę samą wartość. W drugim przypadku, odnoszą się one do tego samego obiektu.

\index{is operator}
\index{operator!is}

Aby sprawdzić, czy dwie zmienne odnoszą się do tego samego obiektu, możesz użyć operatora `is`.

~~~~ {.python .trinket}
>>> a = 'banan'
>>> b = 'banan'
>>> a is b
True
~~~~

W powyższym przykładzie, Python stworzył tylko jeden obiekt ciagu znaków, a obie zmienne `a` i `b` odnoszą się właśnie do tego obiektu.

Ale kiedy tworzysz dwie listy, otrzymujesz dwa obiekty:

~~~~ {.python .trinket}
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> a is b
False
~~~~

W tym przypadku powiedzielibyśmy, że te dwie listy są *równoważne*, ponieważ mają te same elementy, ale nie są *identywne*, ponieważ nie są tym samym obiektem. Jeżeli dwa obiekty są identyczne, to są one również równoważne, ale jeżeli są równoważne, to niekoniecznie są identyczne.

\index{equivalence}
\index{identity}

Do tej pory używaliśmy zamiennie słów "obiekt" i "wartość", ale powinniśmy mówić, że obiekt ma wartość. Jeśli wykonasz `a = [1,2,3]`, to `a` odnosi się do obiektu listy, którego wartością jest konkretna sekwencja elementów. Jeśli inna lista ma te same elementy, to powiedzielibyśmy, że ma taką samą wartość.

\index{object}
\index{value}

Aliasy
------

\index{aliasing}
\index{reference!aliasing}

Jeśli `a` odnosi się do obiektu, a Ty przypisujesz `b = a`, to obie zmienne odnoszą się do tego samego obiektu:

~~~~ {.python .trinket}
>>> a = [1, 2, 3]
>>> b = a
>>> b is a
True
~~~~

Powiązanie zmiennej z obiektem nazywane jest *referencją*. W powyższym przykładzie istnieją dwie referencje do tego samego obiektu.

\index{reference}

Obiekt z więcej niż jedną referencją ma więcej niż jedną nazwę, więc mówimy, że obiekt jest *aliasowany*.

\index{mutability}

Jeżeli aliasowany obiekt jest zmienny, to zmiany dokonane przy użyciu jednego aliasu wpływają na drugi:

~~~~ {.python}
>>> b[0] = 17
>>> print(a)
[17, 2, 3]
~~~~

Chociaż takie zachowanie może być użyteczne, jest ono skłonność do generowania błędów. Ogólnie rzecz biorąc, jeśli pracujesz z obiektami zmiennymi, to bezpieczniej jest unikać tworzenia ich aliasów.

\index{immutability}

W przypadku obiektów niezmiennych, takich jak ciągi znaków, aliasowanie nie jest aż tak dużym problemem. W poniższym przykładzie:

~~~~ {.python}
a = 'banan'
b = 'banan'
~~~~

prawie nigdy nie ma różnicy czy `a` i `b` odnoszą się do tego samego ciągu znaków, czy też nie.

Argumenty będące listami
------------------------

\index{list!as argument}
\index{argument}
\index{argument!list}
\index{reference}
\index{parameter}

When you pass a list to a function, the function gets a reference to the
list. If the function modifies a list parameter, the caller sees the
change. For example, `delete_head` removes the first element from a
list:

~~~~ {.python}
def delete_head(t):
    del t[0]
~~~~

Here's how it is used:

~~~~ {.python .trinket}
>>> letters = ['a', 'b', 'c']
>>> delete_head(letters)
>>> print(letters)
['b', 'c']
~~~~

The parameter `t` and the variable `letters` are
aliases for the same object.

It is important to distinguish between operations that modify lists and
operations that create new lists. For example, the `append`
method modifies a list, but the `+` operator creates a new
list:

\index{append method}
\index{method!append}
\index{list!concatenation}
\index{concatenation!list}

~~~~ {.python .trinket}
>>> t1 = [1, 2]
>>> t2 = t1.append(3)
>>> print(t1)
[1, 2, 3]
>>> print(t2)
None

>>> t3 = t1 + [3]
>>> print(t3)
[1, 2, 3]
>>> t2 is t3
False
~~~~

This difference is important when you write functions that are supposed
to modify lists. For example, this function *does not* delete the head
of a list:

~~~~ {.python}
def bad_delete_head(t):
    t = t[1:]              # WRONG!
~~~~

The slice operator creates a new list and the assignment makes
`t` refer to it, but none of that has any effect on the list
that was passed as an argument.

\index{slice operator}
\index{operator!slice}

An alternative is to write a function that creates and returns a new
list. For example, `tail` returns all but the first element
of a list:

~~~~ {.python}
def tail(t):
    return t[1:]
~~~~

This function leaves the original list unmodified. Here's how it is
used:

~~~~ {.python .trinket}
>>> letters = ['a', 'b', 'c']
>>> rest = tail(letters)
>>> print(rest)
['b', 'c']
~~~~

**Exercise 1: Write a function called `chop` that takes a list and modifies
it, removing the first and last elements, and returns `None`. Then write a function called `middle` that takes a list and returns a new list that contains all but the first and last elements.**

Debugging
---------

\index{debugging}

Careless use of lists (and other mutable objects) can lead to long hours
of debugging. Here are some common pitfalls and ways to avoid them:

1.  Don't forget that most list methods modify the argument and return
    `None`. This is the opposite of the string methods, which
    return a new string and leave the original alone.

    If you are used to writing string code like this:

    ~~~~ {.python}
    word = word.strip()
    ~~~~

    It is tempting to write list code like this:

    ~~~~ {.python}
    t = t.sort()           # WRONG!
    ~~~~

    \index{sort method}
    \index{method!sort}

    Because `sort` returns `None`, the next
    operation you perform with `t` is likely to fail.

    Before using list methods and operators, you should read the
    documentation carefully and then test them in interactive mode. The
    methods and operators that lists share with other sequences (like
    strings) are documented at:

    [docs.python.org/library/stdtypes.html#common-sequence-operations](https://docs.python.org/library/stdtypes.html#common-sequence-operations)

    The methods and operators that only apply to mutable sequences are
    documented at:

    [docs.python.org/library/stdtypes.html#mutable-sequence-types](https://docs.python.org/library/stdtypes.html#mutable-sequence-types)

2.  Pick an idiom and stick with it.

    \index{idiom}

    Part of the problem with lists is that there are too many ways to do
    things. For example, to remove an element from a list, you can use
    `pop`, `remove`, `del`, or even a
    slice assignment.

    To add an element, you can use the `append` method or the
    `+` operator. But don't forget that these are right:

    ~~~~ {.python}
    t.append(x)
    t = t + [x]
    ~~~~

    And these are wrong:

    ~~~~ {.python}
    t.append([x])          # WRONG!
    t = t.append(x)        # WRONG!
    t + [x]                # WRONG!
    t = t + x              # WRONG!
    ~~~~

    Try out each of these examples in interactive mode to make sure you
    understand what they do. Notice that only the last one causes a
    runtime error; the other three are legal, but they do the wrong
    thing.

3.  Make copies to avoid aliasing.

    \index{aliasing!copying to avoid}
    \index{copy!to avoid aliasing}

    If you want to use a method like `sort` that modifies the
    argument, but you need to keep the original list as well, you can
    make a copy.

    ~~~~ {.python}
    orig = t[:]
    t.sort()
    ~~~~

    In this example you could also use the built-in function
    `sorted`, which returns a new, sorted list and leaves the
    original alone. But in that case you should avoid using
    `sorted` as a variable name!

4.  Lists, `split`, and files

    When we read and parse files, there are many opportunities to
    encounter input that can crash our program so it is a good idea to
    revisit the *guardian* pattern when it comes writing
    programs that read through a file and look for a "needle in the
    haystack".

    Let's revisit our program that is looking for the day of the week on
    the from lines of our file:

    ~~~~
    From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008
    ~~~~

    Since we are breaking this line into words, we could dispense with
    the use of `startswith` and simply look at the first word
    of the line to determine if we are interested in the line at all. We
    can use `continue` to skip lines that don't have "From"
    as the first word as follows:

    ~~~~ {.python}
    fhand = open('mbox-short.txt')
    for line in fhand:
        words = line.split()
        if words[0] != 'From' : continue
        print(words[2])
    ~~~~

    This looks much simpler and we don't even need to do the
    `rstrip` to remove the newline at the end of the file.
    But is it better?

    ~~~~
    python search8.py
    Sat
    Traceback (most recent call last):
      File "search8.py", line 5, in <module>
        if words[0] != 'From' : continue
    IndexError: list index out of range
    ~~~~

    It kind of works and we see the day from the first line (Sat), but
    then the program fails with a traceback error. What went wrong? What
    messed-up data caused our elegant, clever, and very Pythonic program
    to fail?

    You could stare at it for a long time and puzzle through it or ask
    someone for help, but the quicker and smarter approach is to add a
    `print` statement. The best place to add the print
    statement is right before the line where the program failed and
    print out the data that seems to be causing the failure.

    Now this approach may generate a lot of lines of output, but at
    least you will immediately have some clue as to the problem at hand.
    So we add a print of the variable `words` right before
    line five. We even add a prefix "Debug:" to the line so we can keep
    our regular output separate from our debug output.

    ~~~~ {.python}
    for line in fhand:
        words = line.split()
        print('Debug:', words)
        if words[0] != 'From' : continue
        print(words[2])
    ~~~~

    When we run the program, a lot of output scrolls off the screen but
    at the end, we see our debug output and the traceback so we know
    what happened just before the traceback.

    ~~~~
    Debug: ['X-DSPAM-Confidence:', '0.8475']
    Debug: ['X-DSPAM-Probability:', '0.0000']
    Debug: []
    Traceback (most recent call last):
      File "search9.py", line 6, in <module>
        if words[0] != 'From' : continue
    IndexError: list index out of range
    ~~~~

    Each debug line is printing the list of words which we get when we
    `split` the line into words. When the program fails, the
    list of words is empty `[]`. If we open the file in a text editor
    and look at the file, at that point it looks as follows:

    ~~~~
    X-DSPAM-Result: Innocent
    X-DSPAM-Processed: Sat Jan  5 09:14:16 2008
    X-DSPAM-Confidence: 0.8475
    X-DSPAM-Probability: 0.0000

    Details: http://source.sakaiproject.org/viewsvn/?view=rev&rev=39772
    ~~~~

    The error occurs when our program encounters a blank line! Of course
    there are "zero words" on a blank line. Why didn't we think of that
    when we were writing the code? When the code looks for the first
    word (`word[0]`) to check to see if it matches "From", we get an
    "index out of range" error.

    This of course is the perfect place to add some
    *guardian* code to avoid checking the first word if
    the first word is not there. There are many ways to protect this
    code; we will choose to check the number of words we have before we
    look at the first word:

    ~~~~ {.python}
    fhand = open('mbox-short.txt')
    count = 0
    for line in fhand:
        words = line.split()
        # print('Debug:', words)
        if len(words) == 0 : continue
        if words[0] != 'From' : continue
        print(words[2])
    ~~~~ 

    First we commented out the debug print statement instead of removing
    it, in case our modification fails and we need to debug again. Then
    we added a guardian statement that checks to see if we have zero
    words, and if so, we use `continue` to skip to the next
    line in the file.

    We can think of the two `continue` statements as helping
    us refine the set of lines which are "interesting" to us and which
    we want to process some more. A line which has no words is
    "uninteresting" to us so we skip to the next line. A line which does
    not have "From" as its first word is uninteresting to us so we skip
    it.

    The program as modified runs successfully, so perhaps it is correct.
    Our guardian statement does make sure that the `words[0]`
    will never fail, but perhaps it is not enough. When we are
    programming, we must always be thinking, "What might go wrong?"

**Exercise 2: Figure out which line of the above program is still not
properly guarded. See if you can construct a text file which causes
the program to fail and then modify the program so that the line is
properly guarded and test it to make sure it handles your new text
file.**

**Exercise 3: Rewrite the guardian code in the above example without
two `if` statements. Instead, use a compound logical
expression using the `or` logical operator with a single
`if` statement.**

Glossary
--------

aliasing
:   A circumstance where two or more variables refer to the same object.
\index{aliasing}

delimiter
:   A character or string used to indicate where a string should be
    split.
\index{delimiter}

element
:   One of the values in a list (or other sequence); also called items.
\index{element}

equivalent
:   Having the same value.
\index{equivalent}

index
:   An integer value that indicates an element in a list.
\index{index}
\index{}

identical
:   Being the same object (which implies equivalence).
\index{identical}

list
:   A sequence of values.
\index{list}

list traversal
:   The sequential accessing of each element in a list.
\index{list!traversal}

nested list
:   A list that is an element of another list.
\index{nested list}

object
:   Something a variable can refer to. An object has a type and a value.
\index{object}

reference
:   The association between a variable and its value.
\index{reference}

Exercises
---------

\index{Romeo and Juliet}

**Exercise 4: Download a copy of the file**
[**www.py4e.com/code3/romeo.txt**](http://www.py4e.com/code3/romeo.txt)**.
Write a program to open the file *romeo.txt* and read it line
by line. For each line, split the line into a list of words using the
`split` function. For each word, check to see if the word is already in a list. If the word is not in the list, add it to the list.
When the program completes, sort and print the resulting words in
alphabetical order.**

~~~~
Enter file: romeo.txt
['Arise', 'But', 'It', 'Juliet', 'Who', 'already',
'and', 'breaks', 'east', 'envious', 'fair', 'grief',
'is', 'kill', 'light', 'moon', 'pale', 'sick', 'soft',
'sun', 'the', 'through', 'what', 'window',
'with', 'yonder']
~~~~

**Exercise 5: Write a program to read through the mail box data and when
you find line that starts with "From", you will split the line into
words using the `split` function. We are interested in who
sent the message, which is the second word on the From line.**

~~~~
From stephen.marquard@uct.ac.za Sat Jan 5 09:14:16 2008
~~~~

**You will parse the From line and print out the second word for each From
line, then you will also count the number of From (not From:) lines and
print out a count at the end. This is a good sample output with a few lines removed:**

~~~~
python fromcount.py
Enter a file name: mbox-short.txt
stephen.marquard@uct.ac.za
louis@media.berkeley.edu
zqian@umich.edu

[...some output removed...]

ray@media.berkeley.edu
cwen@iupui.edu
cwen@iupui.edu
cwen@iupui.edu
There were 27 lines in the file with From as the first word
~~~~

**Exercise 6: Rewrite the program that prompts the user for a list of
numbers and prints out the maximum and minimum of the numbers at the end
when the user enters "done". Write the program to store the numbers the
user enters in a list and use the `max()` and
`min()` functions to compute the maximum and minimum numbers
after the loop completes.**

~~~~
Enter a number: 6
Enter a number: 2
Enter a number: 9
Enter a number: 3
Enter a number: 5
Enter a number: done
Maximum: 9.0
Minimum: 2.0
~~~~
