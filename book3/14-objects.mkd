Programowanie obiektowe
=======================

Zarządzanie większymi programami
--------------------------------

\index{object-oriented}

Na początku książki omówiliśmy cztery podstawowe wzorce programowania, których używamy do tworzenia programów:

* Kod sekwencyjny
* Kod warunkowy (instrukcje `if`)
* Kod powtarzalny (pętle)
* Zapisanie i ponowne użycie (funkcje)

W późniejszych rozdziałach analizowaliśmy proste zmienne, jak również struktury danych, takie jak listy, krotki i słowniki.

Podczas tworzenia programów, projektujemy struktury danych i piszemy kod służący do operowania tymi strukturami danych. Istnieje wiele sposobów pisania programów i prawdopodobnie do tej pory napisałeś już kilka programów, które nie są "zbyt eleganckie", oraz kilka innych programów, które są "bardziej eleganckie". Mimo to, że Twoje programy mogą być małe, to zapewne zaczynasz dostrzegać, że pisanie kodu wymaga odrobiny sztuki i estetyki.

W miarę jak programy stają się długie na miliony wierszy, coraz ważniejsze staje się pisanie kodu, który jest łatwy do zrozumienia. Jeśli pracujesz nad programem o długości miliona linii, nigdy nie możesz mieć w tym samym czasie w głowie całego programu. Potrzebujemy sposobów, aby rozbić duże programy na wiele mniejszych kawałków, tak abyśmy mieli mniej kodu do przeglądania podczas rozwiązywania jakiegoś problemu, naprawiania błędów lub dodawania nowych funkcji.

W pewnym sensie, programowanie obiektowe jest sposobem na uporządkowanie kodu tak, abyś mógł skupić się na jego 50 liniach i go zrozumieć, ignorując na chwilę pozostałe 999 950 linii kodu.

Rozpoczęcie pracy
-----------------

Podobnie jak w przypadku wielu innych aspektów programowania, konieczne jest poznanie koncepcji programowania obiektowego, zanim będzie można je skutecznie wykorzystać. Powinieneś podejść do tego rozdziału jako do sposobu na poznanie niektórych terminów i pojęć oraz powinieneś popracować z kilkoma prostymi przykładami, aby stworzyć podstawy do dalszej nauki.

Kluczowym rezultatem tego rozdziału jest podstawowe zrozumienie, jak konstruowane są obiekty i jak one funkcjonują, a co najważniejsze, jak wykorzystujemy możliwości obiektów, które są nam dostarczane przez Pythona i jego biblioteki.

Korzystanie z obiektów
----------------------

Jak się okazuje, w tej książce przez cały czas używaliśmy obiektów. Python dostarcza nam wiele wbudowanych obiektów. Oto prosty kod, w którym kilka pierwszych linii powinno być dla Ciebie w pewien sposób naturalnych i bardzo łatwych do zrozumienia.

\index{list object}

\VerbatimInput{../code3/party1.py}

Zamiast skupiać się na tym, co te linie ostatecznie realizują, spójrzmy na to, co *naprawdę* dzieje się w tym kodzie z punktu widzenia programowania obiektowego. Nie martw się, jeśli poniższe akapity nie mają dla Ciebie żadnego sensu gdy pierwszy raz je czytasz, ponieważ nie zdefiniowaliśmy jeszcze wszystkich tych terminów.

Pierwsza linia *konstruuje* obiekt typu `list`, druga i trzecia *wywołuje metodę* `append()`, czwarta linia wywołuje metodę `sort()`, a piąta linia *pobiera* (*wyszukuje*) element z pozycji 0.

Szósta linia wywołuje metodę `__getitem__()` na liście `stuff` z parametrem zero.

~~~~ {.python}
print (stuff.__getitem__(0))
~~~~

Siódma linia jest jeszcze bardziej rozwlekłym sposobem na odzyskanie elementu z zerowej pozycji listy `stuff`.

~~~~ {.python}
print (list.__getitem__(stuff,0))
~~~~

W powyższym fragmencie kodu wywołujemy metodę `__getitem__` w klasie `list` i *przekazujemy* jako parametry listę oraz pozycję elementu, który chcemy pobrać z tej listy.

Ostatnie trzy wiersze programu są równoważne, ale wygodniej jest po prostu użyć składni używającej nawiasów kwadratowych, tak aby wyszukać element znajdujący się na konkretnym miejscu listy.

Możemy przyjrzeć się możliwościom danego obiektu, patrząc na wynik funkcji `dir()`:

    >>> stuff = list()
    >>> dir(stuff)
    ['__add__', '__class__', '__contains__', '__delattr__',
    '__delitem__', '__dir__', '__doc__', '__eq__',
    '__format__', '__ge__', '__getattribute__', '__getitem__',
    '__gt__', '__hash__', '__iadd__', '__imul__', '__init__',
    '__iter__', '__le__', '__len__', '__lt__', '__mul__',
    '__ne__', '__new__', '__reduce__', '__reduce_ex__',
    '__repr__', '__reversed__', '__rmul__', '__setattr__',
    '__setitem__', '__sizeof__', '__str__', '__subclasshook__',
    'append', 'clear', 'copy', 'count', 'extend', 'index',
    'insert', 'pop', 'remove', 'reverse', 'sort']
    >>>

Pozostała część tego rozdziału zdefiniuje wszystkie powyższe terminy, więc pamiętaj by po jego zakończeniu wrócić do tej sekcji i ponownie przeczytać powyższe akapity, tak aby sprawdzić czy je rozumiesz.

Zaczynając od programów...
--------------------------

Program w swojej najbardziej podstawowej formie pobiera pewną ilość danych wejściowych, przetwarza je i wytwarza pewną ilość danych wyjściowych. Nasz program do konwersji numerów pięter pokazuje bardzo krótki, ale kompletny program pokazujący wszystkie te trzy kroki.

\VerbatimInput{../code3/elev.py}

Jeśli zastanowimy trochę dłużej nad tym programem, to zauważymy, że istnieje "świat zewnętrzny" oraz nasz program. Aspekty wejściowe i wyjściowe są tymi miejcami, w których program wchodzi w interakcję ze światem zewnętrznym. Wewnątrz programu mamy kod i dane do wykonania zadania, do którego jest przeznaczony ten program.

![Program](height=1.20in@../images/program)

Jednym ze sposobów na myślenie o programowaniu obiektowym jest rozdzielenie naszego programu na wiele "stref". Każda strefa zawiera pewien kod i dane (jak program) oraz ma dobrze zdefiniowane interakcje ze światem zewnętrznym i innymi strefami w programie.

Jeśli spojrzymy ponownie na aplikację do wyodrębniania linków, w której korzystaliśmy z biblioteki BeautifulSoup, to możemy zobaczyć program, który jest skonstruowany poprzez złączenie różnych obiektów w celu wykonania tego zadania:

\index{BeautifulSoup}
\index{HTML}
\index{parsing!HTML}

\VerbatimInput{../code3/urllinks.py}

Wczytujemy adres URL do zmiennej przchowującej ciąg znaków, a następnie przekazujemy ją do `urllib`, tak aby pobrać dane z sieci. Biblioteka `urllib` wykorzystuje w rzeczywistości bibliotekę `socket` do nawiązania połączenia z siecią w celu pobrania danych. Bierzemy ciąg znaków, który zwraca `urllib`, i przekazujemy go do BeautifulSoup do dalszej analizy. BeautifulSoup korzysta z obiektu `html.parser`^[https://docs.python.org/3/library/html.parser.html] i w wyniku też zwraca nam obiekt. Na zwróconym obiekcie wywołujemy metodę `tags()`, która zwraca słownik obiektów będących znacznikami. Przechodzimy w pętli po znacznikach i dla każdego znacznika wywołujemy metodę `get()`, tak aby wypisać jego atrybut `href`.

Możemy narysować dla tego programu diagram z oznaczeniem jak te obiekty ze sobą współpracują.

![Program jako sieć obiektów](height=1.50in@../images/program-oo)

W tym przypadku kluczowe nie jest idealne zrozumienie jak ten program działa, ale zobaczenie jak w celu stworzenia programu budujemy sieć współdziałających ze sobą obiektów i zarządzamy pomiędzy nimi przepływem informacji. Ważne jest również zauważenie, że gdy kilka rozdziałów temu natrafiłeś na ten program, to mogłeś w pełni zrozumieć co się w nim dzieje, nawet nie zdając sobie sprawy z tego, że program "zarządzał przepływem danych pomiędzy obiektami". To były po prostu tylko linie kodu, które wykonały dane zadanie.

Dzielenie problemu na mniejsze podproblemy
------------------------------------------

Jedną z zalet podejścia obiektowego jest to, że może ono ukryć złożoność jakiegoś problemu. Na przykład, podczas gdy my musimy wiedzieć jak używać biblioteki `urllib` i BeautifulSoup, nie musimy wiedzieć jak w środku one działają. Pozwala nam to skupić się na tej części problemu, którą musimy rozwiązać, i pominąć pozostałe części programu.

![Pomijanie szczegółów podczas używania obiektu](height=1.50in@../images/program-oo-code)

Możliwość skupienia się wyłącznie na tej części programu, na której nam zależy, i pomijanie reszty, jest również pomocna dla twórców używanych przez nas obiektów. Na przykład, programiści tworzący BeautifulSoup nie muszą wiedzieć ani dbać o to, w jaki sposób pobieramy naszą stronę HTML, jakie części chcemy przeczytać lub co planujemy zrobić z danymi, które pobieramy ze strony.

![Pomijanie szczegółów podczas budowania obiektu](height=1.50in@../images/program-oo-bs4)

Nasz pierwszy obiekt w Pythonie
-------------------------------

W podstawowym zakresie, obiektem to po prostu jakiś kod plus struktury danych, które są mniejsze niż cały program. Zdefiniowanie funkcji pozwala nam na zapisanie trochę kodu i nadanie mu nazwy, a następnie wywołanie tego kodu za pomocą nazwy funkcji.

Obiekt może zawierać szereg funkcji (które nazywamy *metodami*), jak również dane, które są wykorzystywane przez te funkcje. Dane będące częścią obiektu nazywamy *atrybutami*.

\index{class keyword}

Używamy słowa kluczowego `class` do zdefiniowania danych i kodu, które będą składały się na każdy z tych obiektów. Słowo kluczowe `class` zawiera nazwę klasy i rozpoczyna wcięty blok kodu, w którym umieszczamy atrybuty (dane) i metody (kod).

\VerbatimInput{../code3/party2.py}

Każda metoda wygląda jak funkcja, zaczynająca się od słowa kluczowego `def` i składająca się z wciętego bloku kodu. Nasz obiekt ma jeden atrybut (`x`) i jedną metodę (`party`). Metody te mają specjalny pierwszy parametr, który nazywamy umownie `self`.

Tak jak słowo kluczowe `def` nie powoduje wykonania kodu funkcji, tak samo słowo kluczowe `class` nie tworzy obiektu. Zamiast tego, słowo kluczowe `class` definiuje szablon mówiący o tym jakie dane i kod będą zawarte w każdym obiekcie typu `PartyAnimal`. Klasa jest jak foremka do wykrawania ciastek, a obiekty tworzone przy jej użyciu to ciasteczka^[Prawa autorskie do obrazu ciasteczka: CC-BY
<https://www.flickr.com/photos/dinnerseries/23570475099>]. Nie umieszczasz lukru na foremce do wykrawania ciastek; lukier umieszczasz na ciasteczkach, a na każdym ciasteczku możesz umieścić inny lukier.

![Klasa i dwa obiekty](height=2.0in@../photos/cookie_cutter_flickr_Didriks)

Kontynuując analizę naszego przykładowego program, widzimy pierwszą wykonywalną linię kodu:

~~~~ {.python}
an = PartyAnimal()
~~~~

\index{construct}
\index{object}
\index{instance}
\index{class}

Tutaj instruujemy Pythona, by skonstruował (tzn. stworzył) *obiekt* lub *instancję* klasy `PartyAnimal`. Wygląda to jak wywołanie funkcji o nazwie klasy. Python konstruuje obiekt z odpowiednimi danymi i metodami i zwraca obiekt, który jest następnie przypisany do zmiennej `an`. W pewnym sensie jest to dość podobne do poniższej linii, której używaliśmy już wcześniej:

~~~~ {.python}
counts = dict()
~~~~

Tutaj instruujemy Pythona, by skonstruował obiekt przy użyciu szablonu `dict` (obecnego już w Pythonie), zwrócił instancję słownika i przypisał ją do zmiennej `counts`.

Klasa `PartyAnimal` jest używana do konstruowania obiektu, natomiast zmienna `an` jest używana do wskazywania na ten obiekt. Używamy `an` do dostępu do kodu i danych dla tej konkretnej instancji klasy `PartyAnimal`.

Każdy obiekt/instancja `PartyAnimal` zawiera w sobie zmienną `x` oraz metodę/funkcję o nazwie `party`. W tej linii wywołujemy metodę `party`:

~~~~ {.python}
an.party()
~~~~

Kiedy metoda `party` jest wywoływana, pierwszy parametr (który nazywamy umownie `self`) wskazuje na konkretną instancję obiektu `PartyAnimal`, z której wywoływana jest metoda `party`. W obrębie metody `party` widzimy linię:

~~~~ {.python}
self.x = self.x + 1
~~~~

Składnia ta, używająca operatora *kropki*, mówi '`x` wewnątrz `self`'. Przy każdym wywołaniu `party()`, wewnętrzna wartość `x` jest zwiększana o 1 (a później wartość ta jest wypisywana na ekran przy pomocy `print()`).

Poniższa linia przedstawia kolejny sposób wywołania metody `party` wewnątrz obiektu `an`:

~~~~ {.python}
PartyAnimal.party(an)
~~~~

W tym wariancie uzyskujemy dostęp do kodu bezpośrednio poprzez klasę i jawnie przekazujemy wskaźnik obiektu `an` jako pierwszy parametr metody (tj. `self`). Możesz myśleć o `an.party()` jako o skróconym zapisie powyższej linii.

Po uruchomieniu programu uzyskujemy następujący wynik:

~~~~
Jak na razie 1
Jak na razie 2
Jak na razie 3
Jak na razie 4
~~~~

Konstruujemy obiekt i czterokrotnie wywołujemy metodę `party`, zarówno zwiększając, jak i wypisując wartość `x` będącą wewnątrz obiektu `an`.

Klasy i typy
------------

\index{dir}
\index{type}

Jak już widzieliśmy, w Pythonie wszystkie zmienne mają określony typ. Możemy użyć wbudowanej funkcji `dir` do zbadania możliwości danej zmiennej. Możemy również użyć `type` i `dir` z tworzonymi klasami.

\VerbatimInput{../code3/party3.py}

Po uruchomieniu programu zobaczymy następujący wynik:

~~~~
Type <class '__main__.PartyAnimal'>
Dir  ['__class__', '__delattr__', ...
'__sizeof__', '__str__', '__subclasshook__',
'__weakref__', 'party', 'x']
Type <class 'int'>
Type <class 'method'>
~~~~

Możesz zauważyć, że przy użyciu słowa kluczowego `class` stworzyliśmy nowy typ. W wyniku `dir` możesz zobaczyć, że w obiekcie jest dostępny zarówno atrybut całkowitoliczbowy `x`, jak i metoda `party`.

Cykl życia obiektu
------------------

\index{constructor}
\index{destructor}
\index{object lifecycle}

W poprzednich przykładach definiowaliśmy klasę (szablon), używaliśmy jej do stworzenia instancji (obiektu) tej klasy, a następnie korzystaliśmy z instancji. Kiedy program zakończy pracę, wszystkie zmienne są porzucane. Zazwyczaj nie zastanawiamy się zbytnio nad tworzeniem i usuwaniem zmiennych. Jednak gdy nasze obiekty stają się coraz bardziej złożone, często musimy podjąć wewnątrz obiektu pewne działania, tak aby ustawić niektóre rzeczy w momencie gdy obiekt jest konstruowany i ewentualnie usunąć pewne rzeczy gdy obiekt jest porzucany.

Jeśli chcemy by nasz obiekt był świadomy momentów konstruowania i niszczenia, dodajemy do niego specjalnie nazwane metody:

\VerbatimInput{../code3/party4.py}

Po uruchomieniu programu zobaczymy następujący wynik:

~~~~
Jestem tworzony
Jak na razie 1
Jak na razie 2
Jestem niszczony 2
an zawiera 42
~~~~

Gdy Python tworzy nasz obiekt, to wywołuje naszą metodę `__init__`, tak aby dać nam szansę na ustawienie pewnych domyślnych lub początkowych wartości dla tego obiektu. Kiedy Python natrafi się na linię:

~~~~
an = 42
~~~~

to w rzeczywistości "odrzuca nasz obiekt", więc może ponownie użyć zmiennej `an` do przechowywania wartości `42`. Właśnie w tym momencie, w którym nasz obiekt `an` jest "niszczony", wywoływany jest nasz kod destruktora (`__del__`). Nie możemy powstrzymać naszej zmiennej przed zniszczeniem, ale możemy dokonać niezbędnego czyszczenia tuż przed tym, gdy nasz obiekt już nie będzie istniał.

Często podczas prac nad kodem obiektu zapada decyzja by dodać do niego konstruktor, tak aby ustawić jego początkowe wartości. Natomiast stosunkowo rzadko się zdarzy byśmy potrzebowali destruktora dla danego obiektu.

Wiele instancji
---------------

So far, we have defined a class, constructed a single object, used
that object, and then thrown the object away. However, the real power
in object-oriented programming happens when we construct multiple instances
of our class.

When we construct multiple objects from our class, we might want to set
up different initial values for each of the objects. We can
pass data to the constructors to give each object a different initial
value:

\VerbatimInput{../code3/party5.py}

The constructor has both a `self` parameter that points to the object instance
and additional parameters that are passed into the constructor as the
object is constructed:

~~~~
s = PartyAnimal('Sally')
~~~~

Within the constructor, the second line copies the parameter (`nam`) that is
passed into the `name` attribute within the object instance.

~~~~
self.name = nam
~~~~

The output of the program shows that each of the objects (`s` and `j`) contain their own
independent copies of `x` and `nam`:

~~~~
Sally constructed
Jim constructed
Sally party count 1
Jim party count 1
Sally party count 2
~~~~

Inheritance
-----------

Another powerful feature of object-oriented programming is the ability to
create a new class by extending an existing class.  When extending a class,
we call the original class the *parent class* and the new class the
*child class*.

For this example, we move our `PartyAnimal` class into its own file.
Then, we can 'import' the `PartyAnimal` class in a new file and extend it, as follows:

\VerbatimInput{../code3/party6.py}

When we define the `CricketFan` class, we indicate that we are extending
the `PartyAnimal` class.  This means that all of the variables (`x`) and methods
(`party`) from the `PartyAnimal` class are *inherited* by the `CricketFan` class.
For example, within the `six` method in the `CricketFan` class, we 
call the `party` method from the `PartyAnimal` class.

As the program executes, we create `s` and `j` as independent instances
of `PartyAnimal` and `CricketFan`. The `j` object has additional capabilities beyond
the `s` object.

~~~~
Sally constructed
Sally party count 1
Jim constructed
Jim party count 1
Jim party count 2
Jim points 6
['__class__', '__delattr__', ... '__weakref__',
'name', 'party', 'points', 'six', 'x']
~~~~

In the `dir` output for the `j` object (instance of the `CricketFan` class), we see
that it has the attributes and methods of the parent class, as well as the attributes
and methods that were added when the class was extended to create the `CricketFan` class.

Summary
-------

This is a very quick introduction to object-oriented programming that focuses mainly
on terminology and the syntax of defining and using objects.
Let's quickly review the code that we looked at in the beginning of the chapter.
At this point you should fully understand what is going on.

\VerbatimInput{../code3/party1.py}

The first line constructs a `list` *object*.  When Python creates the `list` object,
it calls the *constructor* method (named `__init__`) to set up the internal
data attributes that will be used to store the list data. We have not passed any
parameters to the *constructor*. When the constructor returns, we use the variable
`stuff` to point to the returned instance of the `list` class.

The second and third lines call the `append` method
with one parameter to add a new item at the end of the list by updating the
attributes within `stuff`.  Then in the fourth line,
we call the `sort` method with no parameters to sort the data within the `stuff`
object.

We then print out the first item in the list using the square brackets which are
a shortcut to calling the `__getitem__` method within the `stuff`.  This
is equivalent to calling the `__getitem__` method in the `list` *class*
and passing the `stuff` object as the first parameter and the position
we are looking for as the second parameter.

At the end of the program, the `stuff` object is discarded but not before
calling the *destructor* (named `__del__`) so that the object can clean up any
loose ends as necessary.

Those are the basics of object-oriented programming. There are many additional details
as to how to best use object-oriented approaches when developing large applications
and libraries that are beyond the scope of this chapter.^[If
you are curious about where the `list` class is defined, take a look
at (hopefully the URL won't change)
https://github.com/python/cpython/blob/master/Objects/listobject.c -
the list class is written in a language
called "C". If you take a look at that source code and find it curious
you might want to explore a few Computer Science courses.]

Glossary
--------

attribute
:   A variable that is part of a class.
\index{attribute}

class
:   A template that can be used to construct an object.  Defines
    the attributes and methods that will make up the object.
\index{class}

child class
:   A new class created when a parent class is extended.  The child class
    inherits all of the attributes and methods of the parent class.
\index{child class}

constructor
:   An optional specially named method (`__init__`) that is called at the
    moment when a class is being used to construct an object.
    Usually this is used to set up initial values for the object.
\index{constructor}

destructor
:   An optional specially named method (`__del__`) that is called at the
    moment just before an object is destroyed.  Destructors are rarely
    used.
\index{destructor}

inheritance
:   When we create a new class (child) by extending an
    existing class (parent).  The child class has all the attributes
    and methods of the parent class plus additional attributes and
    methods defined by the child class.
\index{inheritance}

method
:   A function that is contained within a class and the objects
    that are constructed from the class.  Some object-oriented
    patterns use 'message' instead of 'method' to describe this concept.
\index{method}
\index{message}

object
:   A constructed instance of a class.  An object contains all of
    the attributes and methods that were defined by the class.
    Some object-oriented documentation uses the term 'instance'
    interchangeably with 'object'.
\index{method}

parent class
:   The class which is being extended to create a new child class.
    The parent class contributes all of its methods and attributes
    to the new child class.
\index{parent class}








