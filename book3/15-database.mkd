Korzystanie z baz danych i języka SQL
=====================================

Czym jest baza danych?
----------------------

\index{database}

*Baza danych* to plik, który jest zorganizowany w specjalny sposób by mógł przechowywać dane. Większość baz danych jest zorganizowana tak jak słownik w tym sensie, że mapują one klucze na wartości. Największa różnica polega na tym, że baza danych znajduje się na dysku (lub innym trwałym nośniku danych), a więc zachowuje swoje dane po zakończeniu programu. Ponieważ baza danych przechowywana jest na trwałym nośniku, może ona przechowywać znacznie więcej danych niż słownik, co jest ograniczone wielkością pamięci w komputerze.

\index{database!indexes}

Podobnie jak słownik, oprogramowanie bazodanowe jest zaprojektowane tak, aby dodawania i dostęp do danych był bardzo szybki, nawet dla dużych ilości danych. Oprogramowanie bazodanowe utrzymuje swoją wydajność poprzez budowanie *indeksów*, dzięki czemu dane są dodawane do bazy w taki sposób by umożliwić komputerowi szybkie przejście do konkretnego wpisu.

Istnieje wiele różnych systemów bazodanowych, które są wykorzystywane do wielu różnych celów, w tym: Oracle, MySQL, Microsoft SQL Server, PostgreSQL i SQLite. W tej książce skupimy się na SQLite, ponieważ jest to bardzo popularna baza danych i jest już wbudowana w Pythona. SQLite jest przeznaczony do bycia *wbudowanym* (*osadzonym*) w innych aplikacjach, tak aby zapewnić obsługę bazy danych w obrębie tych aplikacji. Na przykład, przeglądarka Firefox również korzysta wewnętrznie z bazy danych SQLite, podobnie jak wiele innych aplikacji.

<http://sqlite.org/>

SQLite doskonale nadaje się do rozwiązywania niektórych informatycznych problemów z zarządzaniem danymi, takich jak robot internetowy do zbierania danych z Twittera, który opiszemy w tym rozdziale.

Pojęcia związane z bazami danych
--------------------------------

Kiedy pierwszy raz spojrzysz na bazę danych, to będzie ona wyglądała jak plik arkusza kalkulacyjnego, który posiada wiele arkuszy. Podstawowe struktury danych w bazie danych to: *tabele*, *wiersze*, i *kolumny*.

![Relacyjne bazy danych](height=2.0in@../images/relational)

W technicznych opisach relacyjnych baz danych pojęcia tabeli, wiersza i kolumny są bardziej formalnie nazywane odpowiednio *relacją*, *krotką* i *atrybutem*. W tym rozdziale użyjemy mniej formalnych pojęć.

Przeglądarka baz SQLite
-----------------------

Co prawda w tym rozdziale skoncentrujemy się na używaniu Pythona do pracy z danymi zawartymi w plikach bazy SQLite, jednak wiele operacji można wykonać wygodniej przy użyciu darmowego oprogramowania *Database Browser for SQLite*:

<https://sqlitebrowser.org/>

Za pomocą tej aplikacji można łatwo tworzyć tabele, wstawiać i edytować dane oraz uruchamiać proste zapytania SQL dotyczące danych zawartych w bazie.

W pewnym sensie przeglądarka bazy danych jest podobna do edytora tekstowego używanego podczas pracy z plikami tekstowymi. Kiedy chcesz wykonać jedną lub kilka operacji na pliku tekstowym, możesz po prostu otworzyć go w edytorze tekstowym i dokonać żądanych zmian. Kiedy musisz wykonać wiele zmian w pliku tekstowym, to często szybciej i wygodniej będzie Ci napisać prosty program Pythona. Ten sam schemat postępowania możesz zastosować podczas pracy z bazami danych. Proste operacje będziesz wykonywał w menedżerze baz danych, a bardziej złożone operacje wygodniej będzi Ci wykonywać w Pythonie.

Tworzenie tabeli w bazie danych
-------------------------------

Bazy danych wymagają bardziej szczegółowo zdefiniowanej struktury niż listy czy słowniki w Pythonie^[SQLite faktycznie pozwala na pewną elastyczność w typie danych przechowywanych w kolumnie, ale w tym rozdziale nasze typy danych będą ściśle określone, dzięki czemu pokazane tutaj idee będą miały zastosowanie również w innych systemach baz danych, np. w MySQL.].

Kiedy w bazie danych tworzymy *tabelę*, to musimy z wyprzedzeniem podać nazwę każdej *kolumny* występującej w tabeli oraz typ danych, który zamierzamy przechowywać w każdej z *kolumn*. Kiedy oprogramowanie bazy danych wie jaki typ danych będzie użyty w każdej kolumnie, może dzięki temu wybrać najbardziej efektywny sposób przechowywania i wyszukiwania danych w oparciu o ich typ.

Możesz zapoznać się z różnymi typami danych obsługiwanymi przez SQLite pod następującym adresem URL:

<http://www.sqlite.org/datatypes.html>

Zdefiniowanie z góry struktury dla Twoich danych może się początkowo wydawać niewygodne, ale zyskiem z tego jest szybkie uzyskiwanie dostępu do Twoich danych, nawet jeśli baza danych zawiera ich dużą ilość.

Kod tworzący plik bazy danych i tabelę o nazwie `Utwory` z dwiema kolumnami jest następujący:

\index{sqlite3 module}
\index{module!sqlite3}

\VerbatimInput{../code3/db1.py}

\index{connect function}
\index{function!connect}
\index{cursor function}
\index{function!cursor}

Operacja `connect` nawiązuje "połączenie" z bazą danych przechowywaną w pliku `muzyka.sqlite`, który znajduje się w bieżącym katalogu. Jeśli plik ten nie istnieje, to zostanie utworzony. Powodem, dla którego nazywa się to "połączeniem" jest to, że czasami baza danych przechowywana jest na "serwerze baz danych", który jest innym komputerem niż ten, na którym uruchamiamy naszą aplikację. W naszych prostych przykładach baza danych będzie po prostu plikiem lokalnym w tym samym katalogu co uruchamiany przez nas kod Pythona.

*Kursor* jest podobny uchwytu pliku i używamy go do wykonania operacji na danych przechowywanych w bazie. Wywołanie `cursor()` jest koncepcyjnie bardzo podobne do wywołania `open()` podczas pracy z plikami tekstowymi.

![Kursor bazodanowy](height=2.0in@../images/cursor)

Posiadając kursor, przy użyciu metody `execute()` możemy rozpocząć wykonywanie poleceń działających na zawartości bazy danych.

Komendy bazy danych są wyrażone w specjalnym języku, który został ustandaryzowany u wielu różnych dostawców baz danych, tak aby umożliwić nam naukę jednego języka bazy danych. Język ten nazywa się *Structured Query Language* (z ang. strukturalny język zapytań) lub w skrócie *SQL*.

<https://pl.wikipedia.org/wiki/SQL>

W powyższym przykładzie na naszej bazie danych wykonujemy dwa polecenia SQL. Przyjmuje się, że słowa kluczowe SQL pisze się dużymi literami, a części polecenia, które my dodajemy (takie jak nazwy tabel i kolumn) pisze się małymi literami lub z dużej litery.

Pierwsze polecenie SQL usuwa  z bazy danych tabelę `Utwory`, jeśli ta tabela istnieje. Taki wzorzec postępowania ma po prostu pozwolić nam na wielokrotne uruchamianie tego samego programu do tworzenia tabeli `Utwory`, bez generowania błędu. Zauważ, że polecenie `DROP TABLE` usuwa z bazy danych tabelę i całą jej zawartość (tzn. nie ma tutaj żadnej operacji typu "cofnij").

~~~~ {.python}
cur.execute('DROP TABLE IF EXISTS Utwory')
~~~~

Druga komenda tworzy tabelę o nazwie `Utwory` z kolumną tekstową o nazwie `tytuł` i kolumną całkowitoliczbową o nazwie `odtworzenia`.

~~~~ {.python}
cur.execute('CREATE TABLE Utwory (tytuł TEXT, odtworzenia INTEGER)')
~~~~

Teraz, gdy stworzyliśmy tabelę o nazwie `Utwory`, możemy umieścić w niej pewne dane używając operacji SQL `INSERT`. Ponownie, zaczynamy od nawiązania połączenia z bazą danych i uzyskania kursora. Następnie możemy wykonać polecenia SQL za pomocą tego kursora.

Polecenie SQL `INSERT` wskazuje na to jakiej używamy tabeli, a następnie definiuje nowy wiersz, wymieniając pola, które chcemy umieścić w nowym wierszu `(tytuł, odtworzenia)`, a następnie w `VALUES` wartości, które chcemy umieścić w nowym wierszu. Wartości określone jako znaki zapytania `(?, ?)` wskazują, że rzeczywiste wartości do wstawienia są przekazywane jako krotka `( 'My Way', 15 ) ` będąca drugim parametrem wywołania `execute()`.

\VerbatimInput{../code3/db2.py}

Najpierw wstawiamy poprzez `INSERT` dwa wiersze do naszej tabeli i używamy `commit()` aby wymusić zapis danych do pliku bazy danych.

![Wiersze w tabeli](height=1.5in@../images/tracks)

Następnie używamy polecenia `SELECT` do pobrania wierszy, które właśnie wstawiliśmy w tabeli. W poleceniu `SELECT` wskazujemy, z których kolumn chcielibyśmy pobrać dane `(tytuł, odtworzenia)`, oraz wskazujemy, z której tabeli chcemy pobrać dane. Po wykonaniu polecenia `SELECT`, kursor jest czymś, po czym możemy przejść w pętli `for`. W celu zachowania wydajności, kursor po wykonaniu instrukcji `SELECT` nie odczytuje odrazu wszystkich danych z bazy danych. Zamiast tego, dane są odczytywane na żądanie, tj. w tym wypadku gdy idziemy kolejno przez wiersze w instrukcji `for`.

Wynik działania programu jest następujący:

~~~~
Utwory:
('Thunderstruck', 20)
('My Way', 15)
~~~~

\index{Unicode}

Nasza pętla `for` znajduje dwa wiersze, a każdy z nich jest krotką Pythona, w której pierwsza wartość to `tytuł`, a drugą to `odtworzenia`.

*Uwaga: W innych książkach lub w internecie możesz zobaczyć ciągi znaków rozpoczynające się od `u'`. W Pythonie 2 była to wskazówka, że ciągi znaków są napisami z zestawem znaków Unicode, które są w stanie przechowywać niełacińskie znaki. W Pythonie 3, wszystkie ciągi znaków są domyślnie napisami z zestawem znaków Unicode.*

Na samym końcu programu wykonujemy polecenie SQL `DELETE` aby usunąć wiersze, które właśnie utworzyliśmy, dzięki czemu możemy nasz program uruchamiać wielokrotnie bez wystąpienia błędu. Polecenie `DELETE` pokazuje użycie klauzuli `WHERE`, która pozwala nam wyrazić kryterium wyboru, dzięki czemu możemy poprosić bazę danych o zastosowanie polecenia tylko do tych wierszy, które odpowiadają temu kryterium. W tym przykładzie kryterium to stosuje się do wszystkich wierszy, więc czyścimy tabelę, tak by móc wielokrotnie uruchamiać nasz program. Po wykonaniu operacji `DELETE` wywołujemy również `commit()` aby wymusić usunięcie danych z bazy.

Podsumowanie języka SQL
-----------------------

W powyższych przykładach użyliśmy języka SQL i omówiliśmy jego kilka podstawowych poleceń. W tej sekcji przyjrzymy się bliżej językowi SQL i przedstawimy przegląd składni tego języka.

Ponieważ istnieje wielu różnych dostawców baz danych, SQL został ustandaryzowany po to byśmy mogli komunikować się w podobny sposób z bazami danych działających na różnych silnikach.

Relacyjna baza danych składa się z tabel, wierszy i kolumn. Typ danych w kolumnie zazwyczaj jest tekstem, liczbą lub datą. Kiedy tworzymy tabelę, wskazujemy nazwy i typy kolumn:

~~~~ {.sql}
CREATE TABLE Utwory (tytuł TEXT, odtworzenia INTEGER)
~~~~

Aby wstawić wiersz do tabeli, używamy polecenia SQL `INSERT`:

~~~~ {.sql}
INSERT INTO Utwory (tytuł, odtworzenia) VALUES ('My Way', 15)
~~~~

Polecenie `INSERT` określa nazwę tabeli, następnie listę pól/kolumn, które chcesz ustawić w nowym wierszu, a następnie słowo kluczowe `VALUES` i listę odpowiednich wartości dla każdego pola.

Polecenie SQL `SELECT` jest używane do pobierania wierszy i kolumn z bazy danych. Polecenie `SELECT` pozwala określić, które kolumny chcesz pobrać, a także klauzulę `WHERE` by wybrać tylko te wiersze, które chcesz zobaczyć. Polecenie to pozwala także na opcjonalną klauzulę `ORDER BY` kontrolującą sortowanie zwracanych wierszy.

~~~~ {.sql}
SELECT * FROM Utwory WHERE tytuł = 'My Way'
~~~~

Użycie `*` między `SELECT` a `FROM` wskazuje, że chcesz aby baza danych zwróciła wszystkie kolumny dla każdego wiersza, który pasuje do klauzuli `WHERE`.

Zauważ, że w przeciwieństwie do Pythona, w klauzuli SQL `WHERE` używamy pojedynczego znaku równości do wskazania testu na równość, a nie znaku podwójnej równości. Inne operacje logiczne dozwolone w klauzuli `WHERE` obejmują `<`, `>`, `<=`, `>=`, `!=`, jak również `AND` i `OR` oraz nawiasy okrągłe do tworzenia wyrażeń logicznych.

Możesz zażądać, aby zwrócone wiersze były posortowane według którejś z kolumn:

~~~~ {.sql}
SELECT tytuł, odtworzenia FROM Utwory ORDER BY tytuł
~~~~

Aby usunąć wiersz, potrzebna jest klauzula `WHERE` na instrukcji SQL `DELETE`. Klauzula `WHERE` określa, które wiersze mają zostać usunięte:

~~~~ {.sql}
DELETE FROM Utwory WHERE tytuł = 'My Way'
~~~~

Przy użyciu polecenia SQL `UPDATE` możliwa jest aktualiza kolumn w obrębie jednego lub więcej wierszy w tabeli:

~~~~ {.sql}
UPDATE Utwory SET odtworzenia = 16 WHERE tytuł = 'My Way'
~~~~

Polecenie `UPDATE` określa tabelę, a następnie po słowie kluczowym `SET` wskazuje listę pól i wartości, które mają zostać zmienione, a następnie mamy opcjonalną klauzulę `WHERE` do wyboru wierszy, które mają zostać zaktualizowane. Pojedyncze wyrażenie `UPDATE` zmienia wszystkie wiersze odpowiadające klauzuli `WHERE`. Jeśli klauzula `WHERE` nie jest określona, to wykonuje ona aktualizację dla wszystkich wierszy znajdujących się w tabeli.

Opisane wyżej cztery podstawowe polecenia SQL (`INSERT`, `SELECT`, `UPDATE` i `DELETE`) pozwalają na wykonanie podstawowych operacji potrzebnych do utworzenia i utrzymania danych.

Zbieranie informacji z Twittera przy użyciu baz danych
------------------------------------------------------

W poniżej sekcji stworzymy prostego robota internetowego, który przejdzie przez kilka kont na Twitterze i na podstawie zebranych informacji zbudujemy bazę danych. *Uwaga: Bądź bardzo ostrożny podczas uruchamiania poniższych programów. Nie chcesz pobierać zbyt dużo danych lub uruchamiać programów zbyt długo, ponieważ Twittera wyłączy Ci dostęp do swojego API.*

Jednym z problemów związanych z każdym rodzajem robota internetowego jest to, że czasami trzeba go wielokrotnie zatrzymywać i uruchamiać ponownie i jednocześnie nie chcemy utracić danych, które do tej pory pobraliśmy. Nie chcemy by ponowne uruchomienie procesu zbierania danych zaczynało się w tym samym punkcie startowym, więc podczas pobierania danych musimy je przechowywać tak, aby nasz program mógł rozpocząć działanie w tym miejscu, w którym ostatnio zakończył pracę.

Zaczniemy od pobrania z Twittera listy znajomych jakiegoś użytkownika i ich statusów, przejrzenia tej listy i dodania każdego ze znajomych do bazy danych, która zostanie użyta w przyszłości do dalszego pobierania danych. Po przetworzeniu znajomych jednej osoby, sprawdzamy naszą bazę danych i bierzemy jednego ze znajomych tego użytkownika. Robimy tak w kółko, wybierając "nieprzetworzną" osobę, pobierając jej listę znajomych i dodając tych znajomych, których jeszcze nie widzieliśmy, do naszej listy do odwiedzenia w przyszłości.

Śledzimy również, ile razy widzieliśmy danego znajomego w bazie danych, aby uzyskać jakiś wskaźnik jego "popularności".

Przechowując na dysku komputera bazę dotyczącą znanych nam kont Twittera, informacji czy już to kontro odwiedziliśmy oraz jak dane konto jest popularne, możemy zatrzymać i uruchomić ponownie nasz program tyle razy, ile chcemy.

Poniższy program jest nieco skomplikowany. Opiera się na kodzie z ćwiczenia z wcześniejszej części książki, która korzysta z API Twittera.

Oto kod źródłowy naszej aplikacji zbierającej informacje z Twittera:

\VerbatimInput{../code3/twspider.py}

Nasza baza danych jest przechowywana w pliku `spider.sqlite` i ma jedną tabelę o nazwie `Twitter`. Każdy wiersz w tabeli `Twitter` ma osobną kolumnę dla nazwy konta, informacji czy pobraliśmy listę znajomych tego konta oraz tego ile razy konto wystąpiło na listach znajomych.

W głównej pętli programu prosimy o podanie nazwy konta Twittera lub "koniec", aby wyjść z programu. Jeżeli użytkownik poda nazwę konta na Twitterze, pobierzemy listę jego znajomych (i jego statusy) oraz dodamy każdego znajomego do bazy danych, o ile jeszcze go tam nie ma. Jeśli znajomy jest już na liście, to w bazie danych dodajemy 1 do pola `znajomi` w danym wierszu tabeli.

Jeśli użytkownik naciśnie przycisk `<Enter>`, to szukamy w bazie danych kolejnego konta na Twitterze, którego jeszcze nie odwiedziliśmy, pobieramy jego znajomych i statusy tego konta, dodajemy znajomych do bazy danych lub aktualizujemy je, zwiększając ich liczbę w `friends`.

Kiedy pozyskamy już listę znajomych i statusy, idziemy w pętli przez wszystkie elementy `user` będące w zwróconym JSONie i dla każdego użytkownika pobieramy `screen_name`. Następnie używamy instrukcji `SELECT` by sprawdzić, czy ten konkretna wartość `screen_name` została już zapisana w bazie danych i pobieramy liczbę znajomych (`friends`), jeśli dany rekord istnieje.

~~~~ {.python}
countnew = 0
countold = 0
for u in js['users']:
    friend = u['screen_name']
    print(friend)
    cur.execute('SELECT znajomi FROM Twitter WHERE nazwa = ? LIMIT 1',
                (friend, ))
    try:
        count = cur.fetchone()[0]
        cur.execute('UPDATE Twitter SET znajomi = ? WHERE nazwa = ?',
                    (count+1, friend))
        countold = countold + 1
    except:
        cur.execute('''INSERT INTO Twitter (nazwa, pobrany, znajomi)
                    VALUES (?, 0, 1)''', (friend, ))
        countnew = countnew + 1
print('Nowe konta=', countnew, ' widziane ponownie=', countold)
conn.commit()
~~~~

Gdy kursor wykona instrukcję `SELECT`, musimy pobrać wiersze. Możemy to zrobić za pomocą pętli `for`, ale ponieważ pobieramy tylko jeden wiersz (`LIMIT 1`), możemy użyć metody `fetchone()` do pobrania pierwszego (i jedynego) wiersza, który jest wynikiem operacji `SELECT`. Ponieważ metoda `fetchone()` zwraca wiersz jako *krotkę* (nawet jeśli jest tylko jedno pole), bierzemy pierwszą wartość z krotki by uzyskać bieżące zliczenie znajomych i wstawić tę wartość do zmiennej `count`.

Jeśli to pobranie się powiedzie, używamy polecenia SQL `UPDATE` z klauzulą `WHERE`, tak aby dodać 1 do kolumny `friends` w wierszu, który pasuje do konta analizowanego znajomego. Zauważ, że w SQL są dwa symbole zastępcze (tzn. znaki zapytania), a drugi parametr `execute()` jest dwuelementową krotką, która przechowuje wartości, które mają być zastąpione w zapytaniu SQL zamiast znaków zapytania.

Jeśli kod w bloku `try` się nie powiedzie, to prawdopodobnie dlatego, że w instrukcji `SELECT` żaden rekord nie pasuje do klauzuli `WHERE name = ?`. Tak więc w bloku `except` używamy polecenia `INSERT` aby dodać do tabeli atrybut znajomego opisujący jego nazwę ekranową, tj. `screen_name`m ze wskazaniem, że nie pobraliśmy jeszcze `screen_name` i ustawiliśmy liczbę znajomych na jeden.

Podsumowując, przy pierwszym uruchomieniu programu i podaniu konta Twittera, program działa w następujący sposób:

~~~~
Podaj nazwę konta na Twitterze lub wprowadź 'koniec': drchuck
Pobieranie http://api.twitter.com/1.1/friends ...
(...)
Nowe konta= 20  widziane ponownie= 0
Podaj nazwę konta na Twitterze lub wprowadź 'koniec': koniec
~~~~

Ponieważ jest to pierwsze uruchomienie programu, baza danych jest pusta (a w zasadzie jej nie ma), więc tworzymy bazę danych w pliku `spider.sqlite` i dodajemy do niej tabelę o nazwie `Twitter`. Następnie pobieramy kilku znajomych i dodajemy ich wszystkich do pustej bazy danych.

W tym momencie moglibyśmy napisać prosty program do wykonywania zrzutu bazy danych, tak aby przyjrzeć się temu, co znajduje się w naszym pliku `spider.sqlite`:

\VerbatimInput{../code3/twdump.py}

Program ten po prostu otwiera bazę danych i pobiera wszystkie kolumny ze wszystkich wierszy znajdujących się w tabeli `Twitter`, a następnie w pętli przechodzi przez przez wszystkie wiersze i wypisuje każdy z nich.

Jeśli uruchomimy powyższy program po pierwszym uruchomieniu naszego robota internetowego, jego wyjście będzie wyglądało następująco:

~~~~
('opencontent', 0, 1)
('lhawthorn', 0, 1)
('steve_coppin', 0, 1)
('davidkocher', 0, 1)
('hrheingold', 0, 1)
...
20 wierszy.
~~~~

W każdym wierszu widzimy nazwę ekranową `screen_name` użytkownika, informację, że jeszcze nie pobraliśmy danych dla tego użytkownika, oraz że każdy w bazie danych ma jednego znajomego.

W tym momencie nasza baza danych odzwierciedla pobieranie danych o znajomych z naszego pierwszego konta na Twitterze (*drchuck*). Możemy uruchomić program ponownie i wskazać mu, by pobrał znajomych z kolejnego "nieprzetworzonego" jeszcze konta, naciskając po prostu `<Enter>` (zamiast podawać nazwę konta na Twitterze). Wynik może być mniej więcej taki (uwaga: możliwe jest, że będziesz musiał kilkukrotnie wcisnąć `<Enter>` by natrafić na sytuację gdy pojawią się konta, które już były widziane wcześniej):

~~~~
Podaj nazwę konta na Twitterze lub wprowadź 'koniec':
Pobieranie http://api.twitter.com/1.1/friends ...
(...)
Nowe konta= 18  widziane ponownie= 2
Podaj nazwę konta na Twitterze lub wprowadź 'koniec':
Pobieranie http://api.twitter.com/1.1/friends ...
(...)
Nowe konta= 17  widziane ponownie= 3
Podaj nazwę konta na Twitterze lub wprowadź 'koniec': koniec
~~~~

Ponieważ wcisnęliśmy `<Enter>` (tzn. nie określiliśmy nazwy konta na Twitterze), wykonywany jest następujący kod:


~~~~ {.python}
if (len(acct) < 1):
    cur.execute('SELECT nazwa FROM Twitter WHERE pobrany = 0 LIMIT 1')
    try:
        acct = cur.fetchone()[0]
    except:
        print('Nie znaleziono niepobranych kont Twittera')
        continue
~~~~

Używamy polecenia SQL `SELECT`, aby pobrać nazwę pierwszego (`LIMIT 1`) użytkownika, który nadal ma ustawioną wartość "czy przetworzyliśmy już tego użytkownika?" na zero. Używamy także formuły `fetchone()[0]` w obrębie bloku `try`/`except` albo by wydobyć z pobranych danych `screen_name`, albo by wyświetlić informację o błędzie i wykonać ponownie pętlę.

Jeśli udało nam się uzyskać z `screen_name` nieprzetworzone jeszcze konto, to pobieramy dane z tego konta w następujący sposób:

~~~~ {.python}
url = twurl.augment(TWITTER_URL, {'screen_name': acct, 'count': '20'})
print('Pobieranie', url)
connection = urlopen(url, context=ctx)
data = connection.read().decode()
# ...
js = json.loads(data)
# ...
cur.execute('UPDATE Twitter SET pobrany=1 WHERE nazwa = ?', (acct, ))
~~~~

Po pomyślnym pobraniu danych, używamy instrukcji `UPDATE`, aby ustawić kolumnę `retrieved` na 1, po to by wskazać, że zakończyliśmy pobieranie listy znajomych tego konta. Dzięki temu chroni nas to przed wielokrotnym pobieraniem tych samych danych i sprawia, że robimy postępy w budowie sieci znajomych kont Twittera.

Jeśli uruchomimy pierwszy program do pobierania listy znajomych, naciśniemy kilka razy `<Enter>`, aby uzyskać kolejnych nieprzetworzonych jeszcze znajomych jakiegoś znajomego, a następnie uruchomimy program do zrzucania danych z bazy, to uzyskamy mniej więcej podobny po poniższego wynik (tutaj wciśnięto `<Enter>` dwa razy, ale rzeczywisty aktualny wynik może się różnić):

~~~~
('opencontent', 1, 1)
('lhawthorn', 1, 1)
('steve_coppin', 0, 1)
('davidkocher', 0, 1)
('hrheingold', 0, 1)
...
('cnxorg', 0, 2)
('knoop', 0, 1)
('kthanos', 0, 2)
('LectureTools', 0, 1)
...
55 wierszy.
~~~~

Widzimy, że poprawnie zapisaliśmy informację, że odwiedziliśmy konta `lhawthorn` i `opencontent`. Również konta `cnxorg` i `kthanos` mają już dwie osoby śledzące. Odkąd pozyskaliśmy znajomych trzech osób (`drchuck`, `opencontent` i `lhawthorn`), nasza tabela ma 55 wierszy dotyczących pobranych użytkowników.

Za każdym razem, gdy uruchomimy program i wciśniemy przycisk `<Enter>`, wybierze on następne nieprzetworzone konto (np. następnym kontem będzie `steve_coppin`), pobierze jego znajomych, oznaczy go jako pobranego, a dla każdego znajomego użytkownika `steve_coppin` albo doda go na końcu tabeli, albo zaktualizuje jego liczbę `znajomi` jeśli już jest w bazie.

Ponieważ wszystkie dane programu są przechowywane na dysku w bazie danych, aktywność robota internetowego może być zawieszana i wznawiana tyle razy, ile chcesz, bez utraty danych.

Podstawy modelowania danych
---------------------------

Prawdziwa siła relacyjnej bazy danych ujawnia się w momencie utworzenia wielu tabel i połączeń pomiędzy nimi. Czynność decydująca o tym jak rozbić dane aplikacji na wiele tabel i ustalić związki między nimi nazywamy *modelowaniem danych*. Dokument projektowy, który pokazuje tabele i ich związki, nazywa się *modelem danych*.

Modelowanie danych jest stosunkowo wyrafinowaną umiejętnością i w tej części wprowadzimy tylko najbardziej podstawowe pojęcia z zakresu modelowania danych relacyjnych. Aby uzyskać więcej szczegółów na temat modelowania danych, możesz zacząć od poniższej strony:

<https://pl.wikipedia.org/wiki/Model_relacyjny>

Powiedzmy, że w aplikacji naszego robota internetowego chodzącego po Twitterze, zamiast po prostu zliczać znajomych danej osoby, chcielibyśmy prowadzić listę wszystkich związków "przychodzących", tak abyśmy mogli znaleźć listę wszystkich osób, które śledzą dane konto.

Ponieważ każdy użytkownik potencjalnie będzie miał wiele kont, które go śledzą, nie możemy po prostu dodać jednej kolumny do naszej tabeli `Twitter`. Tworzymy więc nową tabelę, która śledzi pary znajomych. Poniżej znajduje się prosty sposób na utworzenie takiej tabeli:

~~~~ {.sql}
CREATE TABLE Znajomości (znajomy_od TEXT, znajomy_do TEXT)
~~~~

Za każdym razem, gdy napotykamy osobę, którą śledzi użytkownik `drchuck`, wstawiamy do tabeli wiersz w postaci:

~~~~ {.sql}
INSERT INTO Znajomości (znajomy_od, znajomy_do) VALUES ('drchuck', 'lhawthorn')
~~~~

Ponieważ przetwarzamy na Twitterze 20 znajomych z kanału użytkownika `drchuck`, wstawimy 20 rekordów z "drchuckiem" jako pierwszym parametrem, przez co będziemy wielokrotnie duplikować ciąg w bazie danych.

Tego typu powielanie danych ciągów znaków narusza jedną z najlepszych praktyk *normalizacji baz danych*, która w zasadzie stwierdza, że nigdy nie powinniśmy umieszczać w bazie danych więcej niż jeden raz tych samych danych ciągów znaków. Jeżeli potrzebujemy tych danych więcej niż jeden raz, tworzymy dla tych danych numeryczny *klucz* i odwołujemy się do rzeczywistych danych za pomocą tego klucza.

W praktyce ciąg znaków zajmuje na dysku i w pamięci naszego komputera dużo więcej miejsca niż liczba całkowita, a porównywanie i sortowanie zajmuje więcej czasu procesora w przypadku ciągów znaków. Jeśli mamy tylko kilkaset wpisów, to czas związany z dostępem i przetwarzaniem danych nie ma większego znaczenia. Ale jeśli mamy milion osób w naszej bazie danych i możliwość 100 milionów powiązań pomiędzy znajomymi, to ważne jest, aby móc jak najszybciej przetworzyć tego typu dane.

Będziemy przechowywać nasze konta na Twitterze w tabeli o nazwie `Ludzie` zamiast używanej w poprzednim przykładzie tabeli `Twitter`. Tabela `Ludzie` posiada dodatkową kolumnę do przechowywania klucza numerycznego powiązanego z wierszem dla tego użytkownika Twittera. SQLite posiada możliwość automatycznego dodawania wartości klucza do każdego wiersza, który wstawiamy do tabeli, osiąganą za pomocą specjalnego typu danych kolumny (`INTEGER PRIMARY KEY`).

Możemy utworzyć tabelę `Ludzie` z dodatkową kolumną `id` w następujący sposób:

~~~~ {.sql}
CREATE TABLE Ludzie
    (id INTEGER PRIMARY KEY, nazwa TEXT UNIQUE, pobrany INTEGER)
~~~~

Zauważ, że w każdym wierszu tabeli `Ludzie` nie zapisujemy już liczby znajomych. Kiedy jako typ naszej kolumny `id` wybierzemy `INTEGER PRIMARY KEY`, to wskazujemy, że chcielibyśmy by SQLite zarządzał tą kolumną i automatycznie przypisywał unikalny klucz numeryczny każdemu wstawianemu wierszowi. Dodajemy również słowo kluczowe `UNIQUE`, aby wskazać, że nie pozwolimy SQLite na wstawienie dwóch wierszy o tej samej wartości dla kolumny `nazwa`.

Teraz zamiast tworzyć wspomnianą wyżej tabelę `Znajomości`, utworzymy tabelę o nazwie `Obserwuje` z dwiema kolumnami całkowitoliczbowymi `id_od` i `id_do` oraz ograniczeniem, że w tej tabeli *kombinacja*/*złożenie* `id_od` i `id_do` musi być unikalna (tzn. nie możemy wstawiać duplikatów wierszy).

~~~~ {.sql}
CREATE TABLE Obserwuje
    (id_od INTEGER, id_do INTEGER, UNIQUE(id_od, id_do) )
~~~~

Kiedy dodajemy do naszych tabel klauzule `UNIQUE`, w rzeczywistości przekazujemy zestaw reguł, o których egzekwowanie prosimy bazę danych przy próbie wstawiania nowych rekordów. Reguły te tworzymy jako pewne udogodnienie w naszych programach, co zobaczymy za chwilę. Reguły te powstrzymują nas przed popełnianiem błędów i ułatwiają napisanie niektórych części naszego kodu.

W istocie, tworząc tabelę `Obserwuje` modelujemy "związek", w którym jedna osoba "obserwuje" drugą, i reprezentujemy ten związek parą liczb (a) wskazując, że jakaś para ludzi jest w jakiś sposób powiązana i (b) wskazując na kierunek tego związku.

![Związki między tabelami](height=3.5in@../images/twitter)

Programowanie z użyciem wielu tabel
-----------------------------------

Napiszemy jeszcze raz kod robota internetowego do chodzenia po kontach użytkowników Twittera, ale tym razem używając dwóch tabel, kluczy głównych i kluczy obcych. Poniżej znajduje się nowa wersja programu:

\VerbatimInput{../code3/twfriends.py}

This program is starting to get a bit complicated, but it illustrates
the patterns that we need to use when we are using integer keys to link
tables. The basic patterns are:

1.  Create tables with primary keys and constraints.

2.  When we have a logical key for a person (i.e., account name) and we
    need the `id` value for the person, depending on whether
    or not the person is already in the `People` table we
    either need to: (1) look up the person in the `People`
    table and retrieve the `id` value for the person or (2)
    add the person to the `People` table and get the
    `id` value for the newly added row.

3.  Insert the row that captures the "follows" relationship.

We will cover each of these in turn.

### Constraints in database tables

As we design our table structures, we can tell the database system that
we would like it to enforce a few rules on us. These rules help us from
making mistakes and introducing incorrect data into out tables. When we
create our tables:

~~~~ {.python}
cur.execute('''CREATE TABLE IF NOT EXISTS People
    (id INTEGER PRIMARY KEY, name TEXT UNIQUE, retrieved INTEGER)''')
cur.execute('''CREATE TABLE IF NOT EXISTS Follows
    (from_id INTEGER, to_id INTEGER, UNIQUE(from_id, to_id))''')
~~~~

We indicate that the `name` column in the `People`
table must be `UNIQUE`. We also indicate that the combination
of the two numbers in each row of the `Follows` table must be
unique. These constraints keep us from making mistakes such as adding
the same relationship more than once.

We can take advantage of these constraints in the following code:

~~~~ {.python}
cur.execute('''INSERT OR IGNORE INTO People (name, retrieved)
    VALUES ( ?, 0)''', ( friend, ) )
~~~~

We add the `OR IGNORE` clause to our `INSERT`
statement to indicate that if this particular `INSERT` would
cause a violation of the "`name` must be unique" rule, the
database system is allowed to ignore the `INSERT`. We are
using the database constraint as a safety net to make sure we don't
inadvertently do something incorrect.

Similarly, the following code ensures that we don't add the exact same
`Follows` relationship twice.

~~~~ {.python}
cur.execute('''INSERT OR IGNORE INTO Follows
    (from_id, to_id) VALUES (?, ?)''', (id, friend_id) )
~~~~

Again, we simply tell the database to ignore our attempted
`INSERT` if it would violate the uniqueness constraint that
we specified for the `Follows` rows.

### Retrieve and/or insert a record

When we prompt the user for a Twitter account, if the account exists, we
must look up its `id` value. If the account does not yet
exist in the `People` table, we must insert the record and
get the `id` value from the inserted row.

This is a very common pattern and is done twice in the program above.
This code shows how we look up the `id` for a friend's
account when we have extracted a `screen_name` from a `user`
node in the retrieved Twitter JSON.

Since over time it will be increasingly likely that the account will
already be in the database, we first check to see if the
`People` record exists using a `SELECT` statement.

If all goes well^[In general, when a sentence starts with "if all goes well" you
will find that the code needs to use try/except.] inside 
the `try` section, we retrieve
the record using `fetchone()` and then retrieve the first
(and only) element of the returned tuple and store it in `friend_id`.

If the `SELECT` fails, the `fetchone()[0]` code
will fail and control will transfer into the `except`
section.

~~~~ {.python}
    friend = u['screen_name']
    cur.execute('SELECT id FROM People WHERE name = ? LIMIT 1',
        (friend, ) )
    try:
        friend_id = cur.fetchone()[0]
        countold = countold + 1
    except:
        cur.execute('''INSERT OR IGNORE INTO People (name, retrieved)
            VALUES ( ?, 0)''', ( friend, ) )
        conn.commit()
        if cur.rowcount != 1 :
            print('Error inserting account:',friend)
            continue
        friend_id = cur.lastrowid
        countnew = countnew + 1
~~~~

If we end up in the `except` code, it simply means that the
row was not found, so we must insert the row. We use `INSERT OR
IGNORE` just to avoid errors and then call `commit()`
to force the database to really be updated. After the write is done, we
can check the `cur.rowcount` to see how many rows were
affected. Since we are attempting to insert a single row, if the number
of affected rows is something other than 1, it is an error.

If the `INSERT` is successful, we can look at
`cur.lastrowid` to find out what value the database assigned
to the `id` column in our newly created row.

### Storing the friend relationship

Once we know the key value for both the Twitter user and the friend in
the JSON, it is a simple matter to insert the two numbers into the
`Follows` table with the following code:

~~~~ {.python}
cur.execute('INSERT OR IGNORE INTO Follows (from_id, to_id) VALUES (?, ?)',
    (id, friend_id) )
~~~~

Notice that we let the database take care of keeping us from
"double-inserting" a relationship by creating the table with a
uniqueness constraint and then adding `OR IGNORE` to our
`INSERT` statement.

Here is a sample execution of this program:

~~~~
Enter a Twitter account, or quit:
No unretrieved Twitter accounts found
Enter a Twitter account, or quit: drchuck
Retrieving http://api.twitter.com/1.1/friends ...
New accounts= 20  revisited= 0
Enter a Twitter account, or quit:
Retrieving http://api.twitter.com/1.1/friends ...
New accounts= 17  revisited= 3
Enter a Twitter account, or quit:
Retrieving http://api.twitter.com/1.1/friends ...
New accounts= 17  revisited= 3
Enter a Twitter account, or quit: quit
~~~~

We started with the `drchuck` account and then let the
program automatically pick the next two accounts to retrieve and add to
our database.

The following is the first few rows in the `People` and
`Follows` tables after this run is completed:

~~~~
People:
(1, 'drchuck', 1)
(2, 'opencontent', 1)
(3, 'lhawthorn', 1)
(4, 'steve_coppin', 0)
(5, 'davidkocher', 0)
55 rows.
Follows:
(1, 2)
(1, 3)
(1, 4)
(1, 5)
(1, 6)
60 rows.
~~~~

You can see the `id`, `name`, and
`visited` fields in the `People` table and you see
the numbers of both ends of the relationship in the `Follows`
table. In the `People` table, we can see that the first three
people have been visited and their data has been retrieved. The data in
the `Follows` table indicates that `drchuck` (user
1) is a friend to all of the people shown in the first five rows. This
makes sense because the first data we retrieved and stored was the
Twitter friends of `drchuck`. If you were to print more rows
from the `Follows` table, you would see the friends of users
2 and 3 as well.

Three kinds of keys
-------------------

Now that we have started building a data model putting our data into
multiple linked tables and linking the rows in those tables using
*keys*, we need to look at some terminology around keys.
There are generally three kinds of keys used in a database model.

-   A *logical key* is a key that the "real world" might
    use to look up a row. In our example data model, the
    `name` field is a logical key. It is the screen name for
    the user and we indeed look up a user's row several times in the
    program using the `name` field. You will often find that
    it makes sense to add a `UNIQUE` constraint to a logical
    key. Since the logical key is how we look up a row from the outside
    world, it makes little sense to allow multiple rows with the same
    value in the table.

-   A *primary key* is usually a number that is assigned
    automatically by the database. It generally has no meaning outside
    the program and is only used to link rows from different tables
    together. When we want to look up a row in a table, usually
    searching for the row using the primary key is the fastest way to
    find the row. Since primary keys are integer numbers, they take up
    very little storage and can be compared or sorted very quickly. In
    our data model, the `id` field is an example of a primary
    key.

-   A *foreign key* is usually a number that points to
    the primary key of an associated row in a different table. An
    example of a foreign key in our data model is the `from_id`.

We are using a naming convention of always calling the primary key field
name `id` and appending the suffix `_id` to any field name
that is a foreign key.

Using JOIN to retrieve data
---------------------------

Now that we have followed the rules of database normalization and have
data separated into two tables, linked together using primary and
foreign keys, we need to be able to build a `SELECT` that
reassembles the data across the tables.

SQL uses the `JOIN` clause to reconnect these tables. In the
`JOIN` clause you specify the fields that are used to
reconnect the rows between the tables.

The following is an example of a `SELECT` with a
`JOIN` clause:

~~~~ {.sql}
SELECT * FROM Follows JOIN People
    ON Follows.from_id = People.id WHERE People.id = 1
~~~~

The `JOIN` clause indicates that the fields we are selecting
cross both the `Follows` and `People` tables. The
`ON` clause indicates how the two tables are to be joined:
Take the rows from `Follows` and append the row from
`People` where the field `from_id` in `Follows` is
the same the `id` value in the `People` table.

![Connecting Tables Using JOIN](height=3.5in@../images/join)

The result of the JOIN is to create extra-long "metarows" which have
both the fields from `People` and the matching fields from
`Follows`. Where there is more than one match between the
`id` field from `People` and the `from_id` from
`People`, then JOIN creates a metarow for *each* of the
matching pairs of rows, duplicating data as needed.

The following code demonstrates the data that we will have in the
database after the multi-table Twitter spider program (above) has been
run several times.

\VerbatimInput{../code3/twjoin.py}

In this program, we first dump out the `People` and
`Follows` and then dump out a subset of the data in the
tables joined together.

Here is the output of the program:

~~~~
python twjoin.py
People:
(1, 'drchuck', 1)
(2, 'opencontent', 1)
(3, 'lhawthorn', 1)
(4, 'steve_coppin', 0)
(5, 'davidkocher', 0)
55 rows.
Follows:
(1, 2)
(1, 3)
(1, 4)
(1, 5)
(1, 6)
60 rows.
Connections for id=2:
(2, 1, 1, 'drchuck', 1)
(2, 28, 28, 'cnxorg', 0)
(2, 30, 30, 'kthanos', 0)
(2, 102, 102, 'SomethingGirl', 0)
(2, 103, 103, 'ja_Pac', 0)
20 rows.
~~~~

You see the columns from the `People` and
`Follows` tables and the last set of rows is the result of
the `SELECT` with the `JOIN` clause.

In the last select, we are looking for accounts that are friends of
"opencontent" (i.e., `People.id=2`).

In each of the "metarows" in the last select, the first two columns are
from the `Follows` table followed by columns three through
five from the `People` table. You can also see that the
second column (`Follows.to_id`) matches the third column
(`People.id`) in each of the joined-up "metarows".

Summary
-------

This chapter has covered a lot of ground to give you an overview of the
basics of using a database in Python. It is more complicated to write
the code to use a database to store data than Python dictionaries or
flat files so there is little reason to use a database unless your
application truly needs the capabilities of a database. The situations
where a database can be quite useful are: (1) when your application
needs to make small many random updates within a large data set, (2)
when your data is so large it cannot fit in a dictionary and you need to
look up information repeatedly, or (3) when you have a long-running
process that you want to be able to stop and restart and retain the data
from one run to the next.

You can build a simple database with a single table to suit many
application needs, but most problems will require several tables and
links/relationships between rows in different tables. When you start
making links between tables, it is important to do some thoughtful
design and follow the rules of database normalization to make the best
use of the database's capabilities. Since the primary motivation for
using a database is that you have a large amount of data to deal with,
it is important to model your data efficiently so your programs run as
fast as possible.

Debugging
---------

One common pattern when you are developing a Python program to connect
to an SQLite database will be to run a Python program and check the
results using the Database Browser for SQLite. The browser allows you to
quickly check to see if your program is working properly.

You must be careful because SQLite takes care to keep two programs from
changing the same data at the same time. For example, if you open a
database in the browser and make a change to the database and have not
yet pressed the "save" button in the browser, the browser "locks" the
database file and keeps any other program from accessing the file. In
particular, your Python program will not be able to access the file if
it is locked.

So a solution is to make sure to either close the database browser or
use the *File* menu to close the database in the browser
before you attempt to access the database from Python to avoid the
problem of your Python code failing because the database is locked.

Glossary
--------

attribute
:   One of the values within a tuple. More commonly called a "column" or
    "field".
\index{attribute}

constraint
:   When we tell the database to enforce a rule on a field or a row in a
    table. A common constraint is to insist that there can be no
    duplicate values in a particular field (i.e., all the values must be
    unique).
\index{constraint}

cursor
:   A cursor allows you to execute SQL commands in a database and
    retrieve data from the database. A cursor is similar to a socket or
    file handle for network connections and files, respectively.
\index{cursor}

database browser
:   A piece of software that allows you to directly connect to a
    database and manipulate the database directly without writing a
    program.
\index{database browser}

foreign key
:   A numeric key that points to the primary key of a row in another
    table. Foreign keys establish relationships between rows stored in
    different tables.
\index{foreign key}

index
:   Additional data that the database software maintains as rows and
    inserts into a table to make lookups very fast.
\index{index}
\index{}

logical key
:   A key that the "outside world" uses to look up a particular row. For
    example in a table of user accounts, a person's email address might
    be a good candidate as the logical key for the user's data.
\index{logical key}

normalization
:   Designing a data model so that no data is replicated. We store each
    item of data at one place in the database and reference it elsewhere
    using a foreign key.
\index{normalization}
\index{database normalization}

primary key
:   A numeric key assigned to each row that is used to refer to one row
    in a table from another table. Often the database is configured to
    automatically assign primary keys as rows are inserted.
\index{primary key}

relation
:   An area within a database that contains tuples and attributes. More
    typically called a "table".
\index{relation}

tuple
:   A single entry in a database table that is a set of attributes. More
    typically called "row".

\index{tuple}

