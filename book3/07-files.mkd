Pliki
=====

\index{file}
\index{type!file}

Pamięć nieulotna
----------------

\index{persistence}
\index{secondary memory}

Do tej pory uczyliśmy się pisać programy i komunikować *procesorowi* nasze zamiary za pomocą instrukcji warunkowych, funkcji i iteracji. Nauczyliśmy się jak tworzyć i wykorzystywać struktury danych w *pamięci głównej*. Procesor i pamięć główna są miejscem, w którym działa i uruchamia się nasze oprogramowanie. To właśnie tam odbywa się całe "myślenie".

Ale jeśli przypomnisz sobie naszą dyskusję na temat architektury sprzętowej, to po wyłączeniu zasilania, wszystko, co jest zapisane na procesorze lub w pamięci głównej, zostanie usunięte. Tak więc do tej pory nasze programy były tylko przejściowymi, zabawowymi ćwiczeniami do nauki Pythona.

![Pamięć pomocnicza](height=2.5in@../images/arch)

W tym rozdziale rozpoczynamy pracę z *pamięcią pomocniczą* (lub plikami). Pamięć pomocnicza nie jest czyszczona po wyłączeniu zasilania. W przypadku pendrive'a, dane, które zapisujemy z naszych programów, mogą zostać usunięte z systemu i przeniesione do innego systemu.

Skupimy się przede wszystkim na odczycie i zapisie plików tekstowych, takich jak te, które tworzymy w edytorze tekstu. Później zobaczymy jak pracować z plikami bazodanowymi, które są plikami binarnymi, przeznaczonymi specjalnie do odczytu i zapisu przez oprogramowanie bazodanowe.

Otwieranie plików
-------------

\index{file!open}
\index{open function}
\index{function!open}

Kiedy chcemy odczytać lub zapisać plik (np. na dysku twardym), musimy najpierw *otworzyć* plik. Otwarcie pliku komunikuje się z Twoim systemem operacyjnym, który wie, gdzie przechowywane są dane dla każdego pliku. Gdy otwierasz plik, prosisz system operacyjny o znalezienie go po nazwie i o upewnienie się, że ten plik istnieje. W poniższym przykładzie otwieramy plik *mbox.txt*, który powinien być przechowywany w tym samym katalogu, w którym znajdujesz się po uruchomieniu Pythona. Możesz pobrać ten plik z [pl.py4e.com/code3/mbox.txt](https://pl.py4e.com/code3/mbox.txt).

~~~~ {.python}
>>> fhand = open('mbox.txt')
>>> print(fhand)
<_io.TextIOWrapper name='mbox.txt' mode='r' encoding='cp1252'>
~~~~

\index{file handle}

Jeśli funkcja `open` się powiedzie, system operacyjny zwróci nam  *uchwyt pliku*. Uchwyt pliku nie jest rzeczywistymi danymi zawartymi w tym pliku, lecz "uchwytem", który możemy użyć do odczytania danych. Otrzymujesz uchwyt, jeśli żądany plik istnieje i masz odpowiednie uprawnienia do jego odczytania.

![A File Handle](height=2.0in@../images/handle)

Jeśli plik nie istnieje, `open` się nie powiedzie, a Ty nie będziesz mógł uzyskać dostępu do jego zawartości:

~~~~ {.python}
>>> fhand = open('stuff.txt')
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
FileNotFoundError: [Errno 2] No such file or directory: 'stuff.txt'
~~~~

Później użyjemy `try` i `except`, tak aby zgrabniej poradzić sobie z sytuacją, w której próbujemy otworzyć nieistniejący plik.

Pliki tekstowe i linie
----------------------

Plik tekstowy może być uważany za sekwencję linii, podobnie jak ciąg znaków w Pythona może być uważany za sekwencję liter, liczb i symboli. Na przykład, poniżej znajduje się fragment pliku tekstowego, który rejestruje aktywność pocztową różnych osób w zespole rozwijającym projekt otwartego oprogramowania:

~~~~
From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008
Return-Path: <postmaster@collab.sakaiproject.org>
Date: Sat, 5 Jan 2008 09:12:18 -0500
To: source@collab.sakaiproject.org
From: stephen.marquard@uct.ac.za
Subject: [sakai] svn commit: r39772 - content/branches/
Details: http://source.sakaiproject.org/viewsvn/?view=rev&rev=39772
...
~~~~

Cały plik interakcji mailowych jest dostępny pod adresem:

[pl.py4e.com/code3/mbox.txt](https://pl.py4e.com/code3/mbox.txt)

a skrócona wersja pliku jest dostępna pod adresem:

[pl.py4e.com/code3/mbox-short.txt](https://pl.py4e.com/code3/mbox-short.txt)

Pliki te są w standardowym formacie pliku zawierającego wiele wiadomości pocztowych. Wiersze rozpoczynające się od "From " oddzielają wiadomości, a wiersze rozpoczynające się od "From:" są częścią wiadomości. Więcej informacji na temat formatu mbox można znaleźć na stronie <https://pl.wikipedia.org/wiki/Mbox>.

Aby podzielić plik na linie, istnieje specjalny znak, który reprezentuje "koniec linii", zwany nomen omen znakiem *końca linii*.

\index{newline}

W ciągach znaków Pythona znak *końca linii* reprezentujemy jako lewy ukośnik-n. Nawet jeśli wygląda to jak dwa znaki, to w rzeczywistości jest to pojedynczy znak. W poniższym przykładzie, gdy patrzymy na zmienną "stuff", wpisując ją w interpreterze, pokazuje nam ona `\n` w ciągu znaków, ale gdy używamy `print` do wyświetlenia ciągu znaków, widzimy go rozbitego na dwie linie przez znak końca linii.

~~~~ {.python}
>>> stuff = 'Witaj\nświecie!'
>>> stuff
'Witaj\nświecie!'
>>> print(stuff)
Witaj
świecie!
>>> stuff = 'X\nY'
>>> print(stuff)
X
Y
>>> len(stuff)
3
~~~~

Widzimy też, że długość ciągu znaków `X\nY` to *trzy* znaki, ponieważ znak końca linii jest pojedynczym znakiem.

Kiedy więc patrzymy na linie w pliku, musimy sobie *wyobrazić*, że na końcu każdej linii znajduje się specjalny niewidoczny znak zwany znakiem końca linii.

Tak więc znak końca linii dzieli znaki w pliku na linie.

Czytanie plików
---------------

\index{file!reading}
\index{counter}

Podczas gdy *uchwyt pliku* nie zawiera danych pliku, to całkiem łatwo jest skonstruować pętlę `for` do jego odczytu i zliczyć linie występujące w pliku:

\VerbatimInput{../code3/open.py}
\begin{trinketfiles}
../code3/mbox-short.txt
\end{trinketfiles}

Możemy użyć uchwytu pliku jako sekwencji w naszej pętli `for`. Nasza pętla `for` po prostu zlicza linie w pliku i wyświetla tę wartość. Przetłumczanie treści pętli `for` na polski jest z grubsza następujące: "dla każdej linii w pliku reprezentowanej przez uchwyt pliku, dodaj jeden do zmiennej `count`".

Powodem, dla którego funkcja `open` nie odczytuje całego pliku jest to, że plik może być dość duży i zawierać wiele gigabajtów danych. Instrukcja `open` zajmuje zawsze tyle samo czasu, niezależnie od wielkości pliku. Pętla `for` w rzeczywistości powoduje, że dane są odczytywane z pliku.

Gdy plik jest w ten sposób odczytywany przy użyciu pętli `for`, Python zajmuje się podziałem danych z pliku na osobne linie przy użyciu znaku końca linii. Python w każdej iteracji pętli `for` czyta każdą linię od początku aż do wystąpienia znaku końca linii i dołącza go jako ostatni znak w zmiennej `line`.

Ponieważ pętla `for` odczytuje z danych jeden wiersz na raz, może ona efektywnie odczytywać i zliczać wiersze w bardzo dużych plikach, bez obawy, że w pamięci głównej skończy się miejsce na dane. Powyższy program przy użyciu bardzo małej ilości pamięci może zliczać linie w plikach o dowolnym rozmiarze, ponieważ każda linia jest odczytywana, zliczana, a następnie porzucana.

Jeśli wiesz, że plik jest stosunkowo mały w porównaniu z rozmiarem Twojej pamięci głównej, możesz odczytać cały plik za jednym zamachem, używając metody `read` na uchwycie pliku.

~~~~ {.python}
>>> fhand = open('mbox-short.txt')
>>> inp = fhand.read()
>>> print(len(inp))
94626
>>> print(inp[:20])
From stephen.marquar
~~~~

W powyższym przykładzie, cała zawartość (wszystkie 94 626 znaków) pliku *mbox-short.txt* jest wczytywana bezpośrednio do zmiennej `inp`. Do wyświetlenia pierwszych 20 znaków danych z ciągu znaków przechowywanych w `inp` używamy operacji wycinana podciągów.

Gdy plik zostanie odczytany w ten sposób, to wszystkie znaki, łącznie ze wszystkimi liniami i znakami końca linii, są jednym dużym ciągiem znaków znajdującym się w zmiennej `inp`. Dobrym pomysłem jest przechowywanie wyniku funkcji `read` jako zmiennej, ponieważ każde wywołanie `read` wyczerpuje zasób:

~~~~ {.python}
>>> fhand = open('mbox-short.txt')
>>> print(len(fhand.read()))
94626
>>> print(len(fhand.read()))
0
~~~~

Pamiętaj, że ta forma funkcji `open` powinna być używana tylko wtedy, gdy dane pliku zmieszczą się spokojnie w pamięci głównej komputera. Jeśli plik jest zbyt duży, by zmieścić się w pamięci głównej, powinieneś napisać swój program tak, aby odczytać plik w kawałkach używając pętli `for` lub `while`.

Przeszukiwanie pliku
--------------------

When you are searching through data in a file, it is a very common
pattern to read through a file, ignoring most of the lines and only
processing lines which meet a particular condition. We can combine the
pattern for reading a file with string methods to build simple search
mechanisms.

\index{filter pattern}
\index{pattern!filter}

For example, if we wanted to read a file and only print out lines which
started with the prefix "From:", we could use the string method
*startswith* to select only those lines with the desired
prefix:

\VerbatimInput{../code3/search1.py}
\begin{trinketfiles}
../code3/mbox-short.txt
\end{trinketfiles}

When this program runs, we get the following output:

~~~~
From: stephen.marquard@uct.ac.za

From: louis@media.berkeley.edu

From: zqian@umich.edu

From: rjlowe@iupui.edu
...
~~~~

The output looks great since the only lines we are seeing are those
which start with "From:", but why are we seeing the extra blank lines?
This is due to that invisible *newline* character. Each
of the lines ends with a newline, so the `print` statement
prints the string in the variable *line* which includes a
newline and then `print` adds *another* newline, resulting in
the double spacing effect we see.

We could use line slicing to print all but the last character, but a
simpler approach is to use the *rstrip* method which
strips whitespace from the right side of a string as follows:

\VerbatimInput{../code3/search2.py}
\begin{trinketfiles}
../code3/mbox-short.txt
\end{trinketfiles}

When this program runs, we get the following output:

~~~~
From: stephen.marquard@uct.ac.za
From: louis@media.berkeley.edu
From: zqian@umich.edu
From: rjlowe@iupui.edu
From: zqian@umich.edu
From: rjlowe@iupui.edu
From: cwen@iupui.edu
...
~~~~

As your file processing programs get more complicated, you may want to
structure your search loops using `continue`. The basic idea
of the search loop is that you are looking for "interesting" lines and
effectively skipping "uninteresting" lines. And then when we find an
interesting line, we do something with that line.

We can structure the loop to follow the pattern of skipping
uninteresting lines as follows:

\VerbatimInput{../code3/search3.py}
\begin{trinketfiles}
../code3/mbox-short.txt
\end{trinketfiles}

The output of the program is the same. In English, the uninteresting
lines are those which do not start with "From:", which we skip using
`continue`. For the "interesting" lines (i.e., those that
start with "From:") we perform the processing on those lines.

We can use the `find` string method to simulate a text editor
search that finds lines where the search string is anywhere in the line.
Since `find` looks for an occurrence of a string within
another string and either returns the position of the string or -1 if
the string was not found, we can write the following loop to show lines
which contain the string "@uct.ac.za" (i.e., they come from the
University of Cape Town in South Africa):

\VerbatimInput{../code3/search4.py}
\begin{trinketfiles}
../code3/mbox-short.txt
\end{trinketfiles}

Which produces the following output:

~~~~
From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008
X-Authentication-Warning: set sender to stephen.marquard@uct.ac.za using -f
From: stephen.marquard@uct.ac.za
Author: stephen.marquard@uct.ac.za
From david.horwitz@uct.ac.za Fri Jan  4 07:02:32 2008
X-Authentication-Warning: set sender to david.horwitz@uct.ac.za using -f
From: david.horwitz@uct.ac.za
Author: david.horwitz@uct.ac.za
...
~~~~

Here we also use the contracted form of the `if` statement
where we put the `continue ` on the same line as the
`if`. This contracted form of the `if` functions
the same as if the `continue` were on the next line and
indented.

Letting the user choose the file name
-------------------------------------

We really do not want to have to edit our Python code every time we want
to process a different file. It would be more usable to ask the user to
enter the file name string each time the program runs so they can use
our program on different files without changing the Python code.

This is quite simple to do by reading the file name from the user using
`input` as follows:

\VerbatimInput{../code3/search6.py}
\begin{trinketfiles}
../code3/mbox-short.txt
\end{trinketfiles}

We read the file name from the user and place it in a variable named
`fname` and open that file. Now we can run the program
repeatedly on different files.

~~~~
python search6.py
Enter the file name: mbox.txt
There were 1797 subject lines in mbox.txt

python search6.py
Enter the file name: mbox-short.txt
There were 27 subject lines in mbox-short.txt
~~~~

Before peeking at the next section, take a look at the above program and
ask yourself, "What could go possibly wrong here?" or "What might our
friendly user do that would cause our nice little program to
ungracefully exit with a traceback, making us look not-so-cool in the
eyes of our users?"

Using `try, except,` and `open`
-----------------------------------------------------

I told you not to peek. This is your last chance.

What if our user types something that is not a file name?

~~~~
python search6.py
Enter the file name: missing.txt
Traceback (most recent call last):
  File "search6.py", line 2, in <module>
    fhand = open(fname)
FileNotFoundError: [Errno 2] No such file or directory: 'missing.txt'

python search6.py
Enter the file name: na na boo boo
Traceback (most recent call last):
  File "search6.py", line 2, in <module>
    fhand = open(fname)
FileNotFoundError: [Errno 2] No such file or directory: 'na na boo boo'
~~~~

Do not laugh. Users will eventually do every possible thing they can do
to break your programs, either on purpose or with malicious intent. As a
matter of fact, an important part of any software development team is a
person or group called *Quality Assurance* (or QA for
short) whose very job it is to do the craziest things possible in an
attempt to break the software that the programmer has created.

\index{Quality Assurance}
\index{QA}

The QA team is responsible for finding the flaws in programs before we
have delivered the program to the end users who may be purchasing the
software or paying our salary to write the software. So the QA team is
the programmer's best friend.

\index{try statement}
\index{statement!try}
\index{open function}
\index{function!open}
\index{exception!IOError}
\index{IOError}

So now that we see the flaw in the program, we can elegantly fix it
using the `try`/`except` structure. We need to
assume that the `open` call might fail and add recovery code
when the `open` fails as follows:

\VerbatimInput{../code3/search7.py}
\begin{trinketfiles}
../code3/mbox-short.txt
\end{trinketfiles}

The `exit` function terminates the program. It is a function
that we call that never returns. Now when our user (or QA team) types in
silliness or bad file names, we "catch" them and recover gracefully:

~~~~
python search7.py
Enter the file name: mbox.txt
There were 1797 subject lines in mbox.txt

python search7.py
Enter the file name: na na boo boo
File cannot be opened: na na boo boo
~~~~

\index{Pythonic}

Protecting the `open` call is a good example of the proper
use of `try` and `except` in a Python program. We
use the term "Pythonic" when we are doing something the "Python way". We
might say that the above example is the Pythonic way to open a file.

Once you become more skilled in Python, you can engage in repartee with
other Python programmers to decide which of two equivalent solutions to
a problem is "more Pythonic". The goal to be "more Pythonic" captures
the notion that programming is part engineering and part art. We are not
always interested in just making something work, we also want our
solution to be elegant and to be appreciated as elegant by our peers.

Writing files
-------------

\index{file!writing}

To write a file, you have to open it with mode "w" as a second
parameter:

~~~~ {.python}
>>> fout = open('output.txt', 'w')
>>> print(fout)
<_io.TextIOWrapper name='output.txt' mode='w' encoding='cp1252'>
~~~~

If the file already exists, opening it in write mode clears out the old
data and starts fresh, so be careful! If the file doesn't exist, a new
one is created.

The `write` method of the file handle object puts data into
the file, returning the number of characters written. The default write
mode is text for writing (and reading) strings.

~~~~ {.python}
>>> line1 = "This here's the wattle,\n"
>>> fout.write(line1)
24
~~~~

\index{newline}

Again, the file object keeps track of where it is, so if you call
`write` again, it adds the new data to the end.

We must make sure to manage the ends of lines as we write to the file by
explicitly inserting the newline character when we want to end a line.
The `print` statement automatically appends a newline, but
the `write` method does not add the newline automatically.

~~~~ {.python}
>>> line2 = 'the emblem of our land.\n'
>>> fout.write(line2)
24
~~~~

When you are done writing, you have to close the file to make sure that
the last bit of data is physically written to the disk so it will not be
lost if the power goes off.

~~~~ {.python}
>>> fout.close()
~~~~

We could close the files which we open for read as well, but we can be a
little sloppy if we are only opening a few files since Python makes sure
that all open files are closed when the program ends. When we are
writing files, we want to explicitly close the files so as to leave
nothing to chance.

\index{close method}
\index{method!close}

Debugging
---------

\index{debugging}
\index{whitespace}

When you are reading and writing files, you might run into problems with
whitespace. These errors can be hard to debug because spaces, tabs, and
newlines are normally invisible:

~~~~ {.python}
>>> s = '1 2\t 3\n 4'
>>> print(s)
1 2  3
 4
~~~~

\index{repr function}
\index{function!repr}
\index{string representation}

The built-in function `repr` can help. It takes any object as
an argument and returns a string representation of the object. For
strings, it represents whitespace characters with backslash sequences:

~~~~ {.python}
>>> print(repr(s))
'1 2\t 3\n 4'
~~~~

This can be helpful for debugging.

One other problem you might run into is that different systems use
different characters to indicate the end of a line. Some systems use a
newline, represented `\n`. Others use a return character, represented
`\r`. Some use both. If you move files between different systems, these
inconsistencies might cause problems.

\index{end of line character}

For most systems, there are applications to convert from one format to
another. You can find them (and read more about this issue) at
[wikipedia.org/wiki/Newline](wikipedia.org/wiki/Newline). Or, of course,
you could write one yourself.

Glossary
--------

catch
:   To prevent an exception from terminating a program using the
    `try` and `except` statements.
\index{catch}

newline
:   A special character used in files and strings to indicate the end of
    a line.
\index{newline}

Pythonic
:   A technique that works elegantly in Python. "Using try and except is
    the *Pythonic* way to recover from missing files".
\index{Pythonic}

Quality Assurance
:   A person or team focused on insuring the overall quality of a
    software product. QA is often involved in testing a product and
    identifying problems before the product is released.
\index{Quality Assurance}
\index{QA}

text file
:   A sequence of characters stored in permanent storage like a hard
    drive.
\index{text file}

Exercises
---------

**Exercise 1: Write a program to read through a file and print the
contents of the file (line by line) all in upper case. Executing the
program will look as follows:**

~~~~
python shout.py
Enter a file name: mbox-short.txt
FROM STEPHEN.MARQUARD@UCT.AC.ZA SAT JAN  5 09:14:16 2008
RETURN-PATH: <POSTMASTER@COLLAB.SAKAIPROJECT.ORG>
RECEIVED: FROM MURDER (MAIL.UMICH.EDU [141.211.14.90])
     BY FRANKENSTEIN.MAIL.UMICH.EDU (CYRUS V2.3.8) WITH LMTPA;
     SAT, 05 JAN 2008 09:14:16 -0500
~~~~

**You can download the file from** [www.py4e.com/code3/mbox-short.txt](http://www.py4e.com/code3/mbox-short.txt)

**Exercise 2: Write a program to prompt for a file name, and then read
through the file and look for lines of the form:**

~~~~
X-DSPAM-Confidence: 0.8475
~~~~

**When you encounter a line that starts with "X-DSPAM-Confidence:" pull
apart the line to extract the floating-point number on the line. Count
these lines and then compute the total of the spam confidence values
from these lines. When you reach the end of the file, print out the
average spam confidence.**

~~~~
Enter the file name: mbox.txt
Average spam confidence: 0.894128046745

Enter the file name: mbox-short.txt
Average spam confidence: 0.750718518519
~~~~

**Test your file on the *mbox.txt* and *mbox-short.txt* files.**

**Exercise 3: Sometimes when programmers get bored or want to have a bit
of fun, they add a harmless *Easter Egg* to their program.
Modify the program that prompts the user for the file name so that it
prints a funny message when the user types in the exact file name "na na
boo boo". The program should behave normally for all other files which
exist and don't exist. Here is a sample execution of the program:**

~~~~
python egg.py
Enter the file name: mbox.txt
There were 1797 subject lines in mbox.txt

python egg.py
Enter the file name: missing.tyxt
File cannot be opened: missing.tyxt

python egg.py
Enter the file name: na na boo boo
NA NA BOO BOO TO YOU - You have been punk'd!
~~~~

**We are not encouraging you to put Easter Eggs in your programs; this is
just an exercise.**

